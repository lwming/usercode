#include "TFile.h"
#include "TChain.h"
#include "TH1.h"
#include "TH3.h"
#include "TH2F.h"
#include "TF1.h"
#include "TF2.h"
#include "TProfile.h"
#include "TCanvas.h"
#include "TLegend.h"
#include "TStyle.h"
#include "TPaveStats.h"
#include "TAxis.h"
#include "TMath.h"
#include "TRandom3.h"
#include <iostream>
#include <algorithm>
#include <vector>
#include <exception>
#include <cmath>
#include <random>
#include <iomanip>
#include <fstream>
#include <string>
#include <sstream>
#include "TGraphAsymmErrors.h"
#include "TLorentzVector.h"
//Root includes
#include "TROOT.h"
#include "TSystem.h"
#include "TStyle.h"
#include "FWCore/FWLite/interface/AutoLibraryLoader.h"

//#include "LumiReweightingStandAlone.h"
#include "PUConstants.h"

#if !defined(__CINT__) && !defined(__MAKECINT__)

#include "DataFormats/FWLite/interface/Handle.h"
#include "DataFormats/FWLite/interface/Event.h"
#include "DataFormats/FWLite/interface/ChainEvent.h"

//Headers for the data items
#include "ProductArea/BNcollections/interface/BNelectron.h"
#include "ProductArea/BNcollections/interface/BNevent.h"
#include "ProductArea/BNcollections/interface/BNjet.h"
#include "ProductArea/BNcollections/interface/BNmcparticle.h"
#include "ProductArea/BNcollections/interface/BNmet.h"
#include "ProductArea/BNcollections/interface/BNmuon.h"
#include "ProductArea/BNcollections/interface/BNphoton.h"
#include "ProductArea/BNcollections/interface/BNsupercluster.h"
#include "ProductArea/BNcollections/interface/BNtrack.h"
#include "ProductArea/BNcollections/interface/BNtrigger.h"
#include "ProductArea/BNcollections/interface/BNskimbits.h"
#include "ProductArea/BNcollections/interface/BNtrigobj.h"
#include "ProductArea/BNcollections/interface/BNprimaryvertex.h"


// headers for python config processing

#include "FWCore/PythonParameterSet/interface/PythonProcessDesc.h"
#include "FWCore/ParameterSet/interface/ProcessDesc.h"
#include "FWCore/ParameterSet/interface/FileInPath.h"

#include "NtupleMaker/BEANmaker/interface/BtagWeight.h"
#include "NtupleMaker/BEANmaker/interface/BEANhelper.h"

#include "AnglesUtil.h"
#include "PhysicsTools/Utilities/interface/LumiReweightingStandAlone.h"
// For MVA reprocessing
//#include "TMVAGui.C"
#include "TMVA/Tools.h"
#include "TMVA/Reader.h"
#include "TMVA/MethodCuts.h"

#endif

using std::string;
using std::cout;
using std::endl;

//******************************************************************************
typedef std::vector<float> vfloat;
typedef std::vector<std::vector<float> > vvfloat;
typedef std::vector<std::vector<std::string> > vvstring;
typedef std::vector<string> vstring;
typedef std::vector<bool> vbool;
typedef std::vector<int> vint;
typedef std::vector<TLorentzVector> vLorentz;


// here is where you can change the btag threshold
// Medium combined tag threshold
float btagThres = 0.679;
float btagThresLoose = 0.244;

// super loose combined tag threshold
//float btagThres = 0.244;

using namespace std;

int main ( int argc, char ** argv )
{
   // load framework libraries
   gSystem->Load( "libFWCoreFWLite" );
   gSystem->Load("libNtupleMakerBEANmaker.so");
   AutoLibraryLoader::enable();

   //adding in python config parsing

   if ( argc < 2 ) {
        std::cout << "Usage : " << argv[0] << " [parameters.py]" << std::endl;
        return 2;
   }

   //////////////////////////////////////////////////////////////////
   //
   // Get the python configuration
   //
   // Configuration will have
   //   1. a process object that everyhting is attached to
   //   2. various parameter sets, including input and output
   //  
   /////////////////////////////////////////////////////////////////////
   
   cout << "Unpacking configuation parameters." << endl;
   PythonProcessDesc builder(argv[1],argc,argv);

   edm::ParameterSet const& inputs = builder.processDesc()->getProcessPSet()->getParameter<edm::ParameterSet>("inputs");
   edm::ParameterSet const& outputs = builder.processDesc()->getProcessPSet()->getParameter<edm::ParameterSet>("outputs");
   edm::ParameterSet const& anaParams = builder.processDesc()->getProcessPSet()->getParameter<edm::ParameterSet>("dilAnalysis");

   std::vector<std::string> inputFileNames = inputs.getParameter< std::vector<std::string> >("fileNames");
   std::string outputFileName = outputs.getParameter<std::string >("outputName");
   //// switch between 2011 and 2012
   std::string selectionYearStr = anaParams.getParameter<std::string>("selectionYear");
   std::string tempPUPeriodStr = anaParams.getParameter<std::string>("PUPeriod");
   std::cout << "CONFIG: selectionYear = " << selectionYearStr << std::endl;
   std::cout << "CONFIG: 2012PUPeriod input from command line = " << tempPUPeriodStr << std::endl;

   // Translate PUPeriod into something more relevant
   std::string PUPeriodStr = "";
   if (tempPUPeriodStr == "2012AB"){
     PUPeriodStr = "2012A_13July, 2012A_06Aug, 2012B_13July";
   } else if (tempPUPeriodStr == "2012ABC") {
     PUPeriodStr = "2012A_13July, 2012A_06Aug, 2012B_13July, 2012C_PR, 2012C_24Aug";
   } else if (tempPUPeriodStr == "2012ABCD") {
     PUPeriodStr = "2012A_13July, 2012A_06Aug, 2012B_13July, 2012C_PR, 2012C_24Aug, 2012D_PR";
   } else {
     std::cout << "Couldn't understand PUPeriodStr = " << tempPUPeriodStr << endl;
     exit (12);
   }

   std::cout << "CONFIG: 2012PUPeriod string to be used at setup = " << PUPeriodStr << std::endl;
   
   //JES
   int jes = anaParams.getParameter<int> ("jes");
   int jer = anaParams.getParameter<int> ("jer");
   int btagCSVShape = anaParams.getParameter<int> ("btagCSVShape");
   std::string sampleName = anaParams.getParameter<string>("sampleName");
   TString tmpName = sampleName;
   std::cout <<"CONFIG: using jes = " << jes << " jer = " << jer << " btagShape = " << btagCSVShape << std::endl; 
   if (jes != 0 && jer != 0) {
     cout << "JES and JER are both non-0 ... exiting" << endl;
     exit(22);
   }

   bool applySelectionJets = anaParams.getParameter<bool>("applySelectionJets");
   bool applySelectionSameSign = anaParams.getParameter<bool>("applySelectionSameSign");
   bool useSideLeptons = false;
   
   bool debug_ = false;

   int maxNentries = inputs.getParameter<int> ("maxEvents");

  typedef BNeventCollection::const_iterator         EventIter;
  typedef BNelectronCollection::const_iterator      EleIter;
  typedef BNjetCollection::const_iterator           JetIter;
  typedef BNmcparticleCollection::const_iterator    MCparIter;
  typedef BNmetCollection::const_iterator           MetIter;
  typedef BNmuonCollection::const_iterator          MuonIter;
  typedef BNphotonCollection::const_iterator        PhotonIter;
  typedef BNprimaryvertexCollection::const_iterator PVIter;
  typedef BNskimbitsCollection::const_iterator      SkimBitIter;
  typedef BNsuperclusterCollection::const_iterator  SCIter;
  typedef BNtrackCollection::const_iterator         TrackIter;
  typedef BNtriggerCollection::const_iterator       TrigIter;
  typedef BNtrigobjCollection::const_iterator       TrigObjIter;


  // data detection
  //
  bool isData = false;
  std::string sysType_lep = "MC";
  if (TString(sampleName).Contains("DoubleElectron")
      || TString(sampleName).Contains("DoubleMu")
      || TString(sampleName).Contains("MuEG")
      || TString(sampleName).Contains("MET")) {

    std::cout << "CONFIG: DATA detected for sample " << sampleName << std::endl;

    isData = true;
    sysType_lep = "data";

  }

  sysType::sysType iSysTypeJE = sysType::NA;
  if (isData || (jer==0 && jes==0)) {
    iSysTypeJE = sysType::NA;
  } else if (jer == 1) {
    iSysTypeJE = sysType::JERup;
  } else if (jer == -1) {
    iSysTypeJE = sysType::JERdown;
  } else if (jes == 1) {
    iSysTypeJE = sysType::JESup;
  } else if (jes == -1) {
    iSysTypeJE = sysType::JESdown;
  }

  sysType::sysType iSysTypeCSV = sysType::NA;
  if (isData || btagCSVShape==0) {
    iSysTypeCSV = sysType::NA;
  } else if (btagCSVShape == 1) {
    iSysTypeCSV = sysType::hfSFup;
  } else if (btagCSVShape == -1) {
    iSysTypeCSV = sysType::hfSFdown;
  } else if (btagCSVShape == 2) {
    iSysTypeCSV = sysType::lfSFup;
  } else if (btagCSVShape == -2) {
    iSysTypeCSV = sysType::lfSFdown;
  }

  sysType::sysType iSysType = sysType::NA;
  if (btagCSVShape == 0) iSysType = iSysTypeJE;
  else iSysType = iSysTypeCSV;
  

  //Sample numbers may not match event->sample; used for setMCsample() only
  int dInt = -9*pow(10,20);
  float dFloat = -9.0*pow(10,20);

  std::string dset = "SingleMu" ;
  int sampleNumber = 999999;
  float weight_Xsec = 1.0;
  float nGen = 1.0;
  float Xsec = 1.0;

  if (selectionYearStr == "2011") {
    if (isData) sampleNumber = -1;
    else if (sampleName == "zjets" || tmpName.Contains("zjets_part")) sampleNumber = 2300; 
    else if (sampleName == "zjets_lowmass") sampleNumber = 2310; 
    else if (sampleName == "wjets") sampleNumber = 2400; 
    else if (sampleName == "ttbar" || tmpName.Contains("ttbar_part")) sampleNumber = 2500;
    else if (sampleName == "ttbar_bb" ) sampleNumber = 2555; 
    else if (sampleName == "ttbar_cc") sampleNumber = 2544; 
    else if (tmpName.Contains("scaleup_ttbar")) sampleNumber = 2510; 
    else if (tmpName.Contains("scaledown_ttbar")) sampleNumber = 2511; 
    else if (sampleName == "ttbarZ") sampleNumber = 2523; 
    else if (sampleName == "ttbarW") sampleNumber = 2524; 
    else if (tmpName.Contains("singlet")) sampleNumber = 2600; 
    else if (sampleName == "ww") sampleNumber = 2700; 
    else if (sampleName == "wz") sampleNumber = 2701; 
    else if (sampleName == "zz") sampleNumber = 2702; 
    else if (tmpName.Contains("ttH")) sampleNumber = 120;
    else assert (sampleName == "sampleName is not in the approved list");
  }
  else if (selectionYearStr == "2012_52x" || selectionYearStr == "2012_53x") {
    if (isData) sampleNumber = -1;
    else if (sampleName == "ttbar" || tmpName.Contains("ttbar_part")) { sampleNumber = 2500;
      nGen = 6912438+1362471; Xsec = 245.8; }
    else if (sampleName == "ttbar_bb" || tmpName.Contains("ttbar_bb_part")) { sampleNumber = 2555;
      nGen = 6912438+1362471; Xsec = 245.8; }
    else if (sampleName == "ttbar_cc" || tmpName.Contains("ttbar_cc_part")) { sampleNumber = 2544;
      nGen = 6912438+1362471; Xsec = 245.8; }
    else if (sampleName == "ttbar_scaleup") sampleNumber = 2511; 
    else if (sampleName == "ttbar_scaledown") sampleNumber = 2510; 
    else if (sampleName == "ttbar_matchingup") sampleNumber = 2513; 
    else if (sampleName == "ttbar_matchingdown") sampleNumber = 2512; 
    else if (sampleName == "ttbar_jj" || tmpName.Contains("ttbar_jj_part")) { sampleNumber = 2566;
      nGen = 31111456; Xsec = 0.457*245.8; 
      weight_Xsec = ( 0.457 / 31111456 ) / ( 1.0 / ( 6912438 + 1362471 )); }
    else if (sampleName == "ttbar_lj" || tmpName.Contains("ttbar_lj_part")) { sampleNumber = 2563;
      nGen = 25165429; Xsec = 0.438*245.8;
      weight_Xsec = ( 0.438 / 25327478 ) / ( 1.0 / ( 6912438 + 1362471 )); }
    else if (sampleName == "ttbar_ll" || tmpName.Contains("ttbar_ll_part")) { sampleNumber = 2533;
      nGen = 12100452; Xsec = 0.105*245.8;
      weight_Xsec = ( 0.105 / 12100452 ) / ( 1.0 / ( 6912438 + 1362471 )); }
    else if (sampleName == "ttbar_cc_jj" || tmpName.Contains("ttbar_cc_jj_part")) { sampleNumber = 2576;
      nGen = 31111456; Xsec = 0.457*245.8;
      weight_Xsec = ( 0.457 / 31111456 ) / ( 1.0 / ( 6912438 + 1362471 )); }
    else if (sampleName == "ttbar_cc_lj" || tmpName.Contains("ttbar_cc_lj_part")) { sampleNumber = 2573;
      nGen = 25327478; Xsec = 0.438*245.8;
      weight_Xsec = ( 0.438 / 25327478 ) / ( 1.0 / ( 6912438 + 1362471 )); }
    else if (sampleName == "ttbar_cc_ll" || tmpName.Contains("ttbar_cc_ll_part")) { sampleNumber = 2543;
      nGen = 12100452; Xsec = 0.105*245.8;
      weight_Xsec = ( 0.105 / 12100452 ) / ( 1.0 / ( 6912438 + 1362471 )); }
    else if (sampleName == "ttbar_bb_jj" || tmpName.Contains("ttbar_bb_jj_part")) { sampleNumber = 2586;
      nGen = 31111456; Xsec = 0.457*245.8;
      weight_Xsec = ( 0.457 / 31111456 ) / ( 1.0 / ( 6912438 + 1362471 )); }
    else if (sampleName == "ttbar_bb_lj" || tmpName.Contains("ttbar_bb_lj_part")) { sampleNumber = 2583;
      nGen = 25327478; Xsec = 0.438*245.8;
      weight_Xsec = ( 0.438 / 25327478 ) / ( 1.0 / ( 6912438 + 1362471 )); }
    else if (sampleName == "ttbar_bb_ll" || tmpName.Contains("ttbar_bb_ll_part")) { sampleNumber = 2553;
      nGen = 12100452; Xsec = 0.105*245.8; 
      weight_Xsec = ( 0.105 / 12100452 ) / ( 1.0 / ( 6912438 + 1362471 )); }
    else if (sampleName == "wjets" || tmpName.Contains("wjets_part")) { sampleNumber = 2400;
      nGen = 57536319; Xsec = 36257; }
    else if (sampleName == "wjets_0p" || tmpName.Contains("wjets_0p_part")) { sampleNumber = 2400;
      nGen = 57536319; Xsec = 36257; }
    else if (sampleName == "wjets_1p" || tmpName.Contains("wjets_1p_part")) { sampleNumber = 2400;
      nGen = 23134881; Xsec = 6440.4;
      weight_Xsec = ( 5400.0 / 23134881 ) / ( 30400.0 / 57536319 ); }
    else if (sampleName == "wjets_2p" || tmpName.Contains("wjets_2p_part")) { sampleNumber = 2400;
      nGen = 33933328; Xsec = 2087.2;
      weight_Xsec = ( 1750.0 / 339333285 ) / ( 30400.0 / 57536319 ); }
    else if (sampleName == "wjets_3p" || tmpName.Contains("wjets_3p_part")) { sampleNumber = 2400;
      nGen = 15463420; Xsec = 619.0;
      weight_Xsec = ( 519.0 / 15463420 ) / ( 30400.0 / 57536319 ); }
    else if (sampleName == "wjets_4p" || tmpName.Contains("wjets_4p_part")) { sampleNumber = 2400;
      nGen = 13365439; Xsec = 255.2;
      weight_Xsec = ( 214.0 / 13365439 ) / ( 30400.0 / 57536319 ); } 
    else if (sampleName == "zjets_lowmass" || tmpName.Contains("zjets_lowmass_part")) { sampleNumber = 2850;
      nGen = 37828841; Xsec = 14702; }
    else if (sampleName == "zjets_lowmass_1p" || tmpName.Contains("zjets_lowmass_1p_part")) { sampleNumber = 2851;
      weight_Xsec = ( 716.0 / 8039604 ) / ( 11050.0 / 37828841 ); }
    else if (sampleName == "zjets_lowmass_2p" || tmpName.Contains("zjets_lowmass_2p_part")) { sampleNumber = 2852;
      weight_Xsec = ( 309.7 / 30684442 ) / ( 11050.0 / 37828841 ); }
    else if (sampleName == "zjets" || tmpName.Contains("zjets_part")) { sampleNumber = 2800;
      nGen =  30072710; Xsec = 3505.7; }
    else if (sampleName == "zjets_0p" || tmpName.Contains("zjets_0p_part")) { sampleNumber = 2800;
      nGen =  30072710; Xsec = 3505.7; }
    else if (sampleName == "zjets_1p" || tmpName.Contains("zjets_1p_part")) { sampleNumber = 2801;
      nGen = 24032562; Xsec = 666.7;
      weight_Xsec = ( 561.0 / 24032562 ) / ( 2950.0 /  30072710 ); }
    else if (sampleName == "zjets_2p" || tmpName.Contains("zjets_2p_part")) { sampleNumber = 2802;
      nGen = 2350806; Xsec = 215.1;
      weight_Xsec = ( 181.0 / 2350806 ) / ( 2950.0 /  30072710 ); }
    else if (sampleName == "zjets_3p" || tmpName.Contains("zjets_3p_part")) { sampleNumber = 2803;
      nGen = 10753491; Xsec = 66.07;
      weight_Xsec = ( 55.6 / 10753491 ) / ( 2950.0 /  30072710 ); }
    else if (sampleName == "zjets_4p" || tmpName.Contains("zjets_4p_part")) { sampleNumber = 2804;
      nGen = 6370630; Xsec = 27.38;
      weight_Xsec = ( 23.04 /6370630 ) / ( 2950.0 /  30072710 ); }
    else if (sampleName == "singlet_s") { sampleNumber = 2600;
      nGen = 259657; Xsec = 3.79; }
    else if (sampleName == "singlet_s_ll") sampleNumber = 2630;
    else if (sampleName == "singletbar_s") { sampleNumber = 2601;
      nGen = 139835; Xsec = 1.76; }
    else if (sampleName == "singletbar_s_ll") sampleNumber = 2631; 
    else if (sampleName == "singlet_t") { sampleNumber = 2602;
      nGen = 3744404; Xsec = 56.4; }
    else if (sampleName == "singlet_t_ll") sampleNumber = 2632; 
    else if (sampleName == "singletbar_t") { sampleNumber = 2603;
      nGen = 1933504; Xsec = 30.7; }
    else if (sampleName == "singletbar_t_ll") sampleNumber = 2633; 
    else if (sampleName == "singlet_tW") { sampleNumber = 2604;
      nGen = 496918; Xsec = 11.1; }
    else if (sampleName == "singlet_tW_lj") sampleNumber = 2654; 
    else if (sampleName == "singlet_tW_jl") sampleNumber = 2664; 
    else if (sampleName == "singlet_tW_ll") sampleNumber = 2634; 
    else if (sampleName == "singletbar_tW") { sampleNumber = 2605;
      nGen = 492779; Xsec = 11.1; }
    else if (sampleName == "singletbar_tW_lj") sampleNumber = 2555; 
    else if (sampleName == "singletbar_tW_jl") sampleNumber = 2565; 
    else if (sampleName == "singletbar_tW_ll") sampleNumber = 2535; 
    else if (sampleName == "ww") { sampleNumber = 2700;
      nGen = 9955089; Xsec = 54.8; }
    else if (sampleName == "ww_ll") { sampleNumber = 2700;
      nGen = 1931931; Xsec = 54.8*0.324*0.324; }
    else if (sampleName == "www") { sampleNumber = 2710;
      nGen = 220040; Xsec =  0.08217; }
    else if (sampleName == "wwz") { sampleNumber = 2720;
      nGen = 221576; Xsec = 0.0633; }
    else if (sampleName == "wwG") { sampleNumber = 2720;
      nGen = 94500; Xsec = 0.0000001; } //AWB incorrect values
    else if (sampleName == "wz") { sampleNumber = 2701;
      nGen = 9931257; Xsec = 32.3; }
    else if (sampleName == "wz_lll") { sampleNumber = 2731;
      nGen = 1987010; Xsec = 32.3*0.324*0.101; }
    else if (sampleName == "wz_lljj") { sampleNumber = 2761;
      nGen = 3212461; Xsec = 32.3*0.101*(1-0.324); }
    else if (sampleName == "wz_ljj") { sampleNumber = 2791;
      nGen = 2906320; Xsec = 32.3*0.324*0.699; }
    else if (sampleName == "wzz") { sampleNumber = 2721;
      nGen = 219835; Xsec = 0.01922; } //AWB doesn't exist in new GT?
    else if (sampleName == "zz") { sampleNumber = 2702;
      nGen = 9755621; Xsec = 7.7; }
    else if (sampleName == "zz_llll") { sampleNumber = 2732;
      nGen = 4804217; Xsec = 7.7*0.101*0.101; }
    else if (sampleName == "zz_lljj") { sampleNumber = 2762;
      nGen = 1934806; Xsec = 7.7*2*0.101*0.699; }
    else if (sampleName == "zzz") { sampleNumber = 2722;
      nGen = 224519; Xsec = 0.004587; }
    else if (sampleName == "ttbarW") { sampleNumber = 2524;
      nGen = 195396; Xsec = 0.249; }
    else if (sampleName == "ttbarWW") { sampleNumber = 2534;
      nGen = 216867; Xsec = 0.002037; }
    else if (sampleName == "ttbarZ") { sampleNumber = 2523;
      nGen = 209512; Xsec = 0.208; }
    else if (sampleName == "ttbarG") { sampleNumber = 2560;
      nGen = 71405; Xsec = 0.0000001; } //AWB incorrect value
    else if (sampleName == "ttbarttbar") { sampleNumber = 2525;
      nGen = 99994; Xsec = 0.000716; } //AWB doesn't exist in new GT?
    else if (sampleName == "VH_tautau") { sampleNumber = 2915;
      nGen = 200124; Xsec = 0.07717352; } //AWB doesn't exist in new GT?
    else if (sampleName == "VH_ZZ") { sampleNumber = 2923;
      nGen = 500409; Xsec = 0.03223704; } //AWB doesn't exist in new GT?
    else if (sampleName == "VH_WW") { sampleNumber = 2924;
      nGen = 200408; Xsec = 0.2625365; } //AWB doesn't exist in new GT?
    else if (tmpName.Contains("ttH") && selectionYearStr == "2012_52x") {
      if (tmpName.Contains("FullSim")) sampleNumber = 8120;
      else sampleNumber = 9120;
    }
    else if (tmpName.Contains("ttH") && selectionYearStr == "2012_53x") {
      if (tmpName.Contains("_tautau")) { sampleNumber = 7120;
        nGen = 992997; Xsec = 0.1302*0.1302; }
      else if (tmpName.Contains("_bb")) { sampleNumber = 8120;
        nGen = 980931; Xsec = 0.1302*0.577; }
      else { sampleNumber = 9120;
        nGen = 992997; Xsec = 0.1302; }
    }
    else assert (sampleName == "sampleName is not in the approved list");
  }
  else {
    assert (selectionYearStr == "either 2012_52x, 2012_53x, or 2011");
  }


  std::cout << "CONFIG: Sample Name = " << sampleName
            << ", sample Number = " << sampleNumber << endl;

  
  BEANhelper beanHelper;
  //BEANhelper::SetUp(string iEra, int iSampleNumber, analysisType::analysisType, bool iIsData, string iDataset, bool iReshapeCSV, bool iPfLeptons = true)
  if (debug_) std::cout << "BEANhelper::SetUp(string iEra, int iSampleNumber, analysisType::analysisType, bool iIsData, string iDataset, bool iReshapeCSV, bool iPfLeptons = true)" << std::endl;
  if (debug_) std::cout << "beanHelper.SetUp(" << selectionYearStr << " , "
                        << sampleNumber << " , analysisType::DIL  " << isData << " , "
                        << dset << " , true, true );" << std::endl;
  beanHelper.SetUp(selectionYearStr,sampleNumber,analysisType::DIL,isData,dset,false,true,PUPeriodStr);
  if (debug_) std::cout << "beanHelper.SetUp successful" << std::endl;
  
  // Load the files
  vstring fileNames = inputFileNames;

  if (fileNames.size() < 1 ){
    cout << "You don't have any files in your list... this is is probably bad... exiting" << endl;
    exit(22);
  }

  
  // Name of file containing histograms
  std::cout << "Writing out to file " << outputFileName << endl;


  // ================= TMVA STUFF  =====================

  // One NN for each category (just tag categories for now)
  // One NN for each category
  // 
  
  std::vector< TString >catList ;
//   catList.push_back("ge3t_v1");
//   catList.push_back("ge3t_v2");
//   catList.push_back("ge4je2t_v1");   /////
//   catList.push_back("e3je2t_v1");   /////
//   catList.push_back("e2je2t_v1");

//   catList.push_back("e2je2t_oldvar");   /////
//   catList.push_back("e3je2t_53x");   /////
//   catList.push_back("ge4je2t_53x");   /////
//   catList.push_back("ge3t_53x");   /////

// //   catList.push_back("eq3jeq3t_ttbar");
// //   catList.push_back("ge4jge3t_ttbar");

//   catList.push_back("SS_ge3jge0t_ttbar");
// //   catList.push_back("SS_ge3jge1t_ttW");
  
  const unsigned int nCat = catList.size();

  //Float_t fCFMlpANN[nCat];
  //TBranch* branchCFMlpANN[nCat] ;

  //Robin's variables
  Float_t                 varavg_btag_disc_non_btags;
  Float_t                 vardijet_mass_third;
  Float_t                 vardijet_mass_first;
  Float_t                 varavg_dijet_mass;
  Float_t                 vardijet_mass_m2H;
  Float_t              varfirst_jet_pt ;
  //Opposite sign variables
  Float_t                 varavg_btag_disc_btags;
  Float_t                 varavg_dr_jets;
  Float_t                 varmin_dr_jets;
  Float_t                 varHt;
  Float_t                 varhiggsLike_dijet_mass;
  Float_t                 varhiggsLike_dijet_mass2;
  Float_t                 varmin_dr_tagged_jets; 
  Float_t                 varnumHiggsLike_dijet_15_float;
  Float_t                 varnumJets_float; 
  Float_t                 varmindr_lep1_jet;
  Float_t                 varsum_jet_pt;
  Float_t                 varsum_pt;
  Float_t                 varall_sum_pt;

  //Same sign vs. ttbar variables
  Float_t                 varcorrectedD0_leplep;
  Float_t                 varlep2Pt;
  Float_t                 varmaxLepChargedIso;
  Float_t                 varMHT;
  Float_t                 varmaxLepAbsEta;
  Float_t                 varmindr_lep2_allJet;
  Float_t                 varmindr_lep2_jet;
//   Float_t                 varnumJets_float;


  //Same sign vs. ttW variables
//   Float_t                 varlep2Pt;
//   Float_t                 varmindr_lep1_allJet;
//   Float_t                 varmindr_lep1_jet;
//   Float_t                 varmindr_lep2_jet;
//   Float_t                 varnumJets_float;
//   Float_t                 varsum_jet_pt;
  

  vector<TMVA::Reader *> reader;

  for( unsigned int j = 0 ; j < nCat ; ++j ){
      TString label = catList[j];
      reader.push_back( new TMVA::Reader( "!Color:!Silent" ));    
      if(j < 2) { 
        reader[j]->AddVariable( "avg_dr_jets", &varavg_dr_jets );
	if (j==1) {
	  reader[j]->AddVariable( "min_dr_tagged_jets", &varmin_dr_tagged_jets );
	  reader[j]->AddVariable( "higgsLike_dijet_mass", &varhiggsLike_dijet_mass );
	}
	reader[j]->AddVariable( "higgsLike_dijet_mass2", &varhiggsLike_dijet_mass2 );
	reader[j]->AddVariable( "numHiggsLike_dijet_15_float", &varnumHiggsLike_dijet_15_float );
	if (j==0) reader[j]->AddVariable( "mindr_lep1_jet", &varmindr_lep1_jet );
        reader[j]->AddVariable( "sum_pt", &varsum_pt );
	reader[j]->AddVariable( "avg_btag_disc_btags", &varavg_btag_disc_btags );

      }
      else if (j == 2){ //>=4j2t
	reader[j]->AddVariable( "avg_dr_jets", &varavg_dr_jets );
	reader[j]->AddVariable( "higgsLike_dijet_mass2", &varhiggsLike_dijet_mass2 );
	reader[j]->AddVariable( "numJets_float", &varnumJets_float );
	reader[j]->AddVariable( "sum_jet_pt", &varsum_jet_pt );
	reader[j]->AddVariable( "avg_btag_disc_non_btags",   &varavg_btag_disc_non_btags   ); 
	reader[j]->AddVariable( "dijet_mass_m2H",         &vardijet_mass_m2H   ); 
      }
      else if (j == 3){ //3j2t
	reader[j]->AddVariable( "avg_dr_jets", &varavg_dr_jets );
	reader[j]->AddVariable( "mindr_lep1_jet", &varmindr_lep1_jet );
	reader[j]->AddVariable( "all_sum_pt", &varall_sum_pt );
	reader[j]->AddVariable( "avg_btag_disc_non_btags",   &varavg_btag_disc_non_btags   ); 
	reader[j]->AddVariable( "dijet_mass_third",         &vardijet_mass_third   ); 
      }
      else if (j == 4){ // 2j2t
	reader[j]->AddVariable( "avg_dr_jets", &varavg_dr_jets );
	reader[j]->AddVariable( "first_jet_pt",         &varfirst_jet_pt   );
	reader[j]->AddVariable( "mindr_lep1_jet", &varmindr_lep1_jet );
	reader[j]->AddVariable( "sum_pt", &varsum_pt );
	reader[j]->AddVariable( "avg_btag_disc_btags",   &varavg_btag_disc_btags   ); 
      }

      /////

      else if(j == 5) { //2j2t_oldvar
	reader[j]->AddVariable( "first_jet_pt",         &varfirst_jet_pt   );
	reader[j]->AddVariable( "min_dr_tagged_jets",         &varmin_dr_tagged_jets   ); 
	reader[j]->AddVariable( "mindr_lep1_jet",         &varmindr_lep1_jet   );
	reader[j]->AddVariable( "avg_btag_disc_btags",         &varavg_btag_disc_btags   );
	reader[j]->AddVariable( "Ht",         &varHt   );
      }
      else if (j==6){ //e3je2t_53x
	reader[j]->AddVariable( "first_jet_pt",         &varfirst_jet_pt   );
	reader[j]->AddVariable( "avg_dr_jets",         &varavg_dr_jets   ); ///
	reader[j]->AddVariable( "min_dr_jets",         &varmin_dr_jets   ); 
	reader[j]->AddVariable( "avg_btag_disc_non_btags",         &varavg_btag_disc_non_btags   ); 
	reader[j]->AddVariable( "dijet_mass_m2H",         &vardijet_mass_m2H   ); 

      }
      else if (j==7){ //ge4je2t_53x
	reader[j]->AddVariable( "avg_dr_jets",         &varavg_dr_jets   ); ///
	reader[j]->AddVariable( "avg_dijet_mass",         &varavg_dijet_mass   ); ///
	reader[j]->AddVariable( "min_dr_jets",         &varmin_dr_jets   ); 
	reader[j]->AddVariable( "dijet_mass_first",         &vardijet_mass_first   ); 
	reader[j]->AddVariable( "avg_btag_disc_non_btags",         &varavg_btag_disc_non_btags   ); 
	reader[j]->AddVariable( "numJets_float",         &varnumJets_float   ); ///
      }
      else if (j==8){ //ge3t_53x
	reader[j]->AddVariable( "avg_dr_jets",         &varavg_dr_jets   ); ///
	reader[j]->AddVariable( "numJets_float",         &varnumJets_float   ); ///
	reader[j]->AddVariable( "min_dr_jets",         &varmin_dr_jets   ); 
	reader[j]->AddVariable( "min_dr_tagged_jets",         &varmin_dr_tagged_jets   ); 
	reader[j]->AddVariable( "avg_btag_disc_btags",         &varavg_btag_disc_btags   );
	reader[j]->AddVariable( "Ht",         &varHt   );
      }
      ///////

      else if (j==9){ //Same Sign
	reader[j]->AddVariable( "correctedD0_leplep",         &varcorrectedD0_leplep   ); ///
	reader[j]->AddVariable( "lep2Pt", &varlep2Pt );
        reader[j]->AddVariable( "maxLepAbsEta", &varmaxLepAbsEta );
	reader[j]->AddVariable( "maxLepChargedIso", &varmaxLepChargedIso );
	reader[j]->AddVariable( "MHT", &varMHT );
	reader[j]->AddVariable( "mindr_lep2_allJet", &varmindr_lep2_allJet );
      }

      /////
//       else if (j==18) {
//         reader[j]->AddVariable( "lep2Pt", &varlep2Pt );
//         reader[j]->AddVariable( "maxLepChargedIso", &varmaxLepChargedIso );
//         reader[j]->AddVariable( "maxLepAbsEta", &varmaxLepAbsEta );
//         reader[j]->AddVariable( "mindr_lep1_jet", &varmindr_lep1_jet );
//         reader[j]->AddVariable( "mindr_lep2_allJet", &varmindr_lep2_allJet );
//         reader[j]->AddVariable( "mindr_lep2_jet", &varmindr_lep2_jet );
//         reader[j]->AddVariable( "numJets_float", &varnumJets_float );
//         reader[j]->AddVariable( "sum_jet_pt", &varsum_jet_pt );
//       }
//       else if (j==19) {
//         reader[j]->AddVariable( "lep2Pt", &varlep2Pt );
//         reader[j]->AddVariable( "mindr_lep1_allJet", &varmindr_lep1_allJet );
//         reader[j]->AddVariable( "mindr_lep1_jet", &varmindr_lep1_jet );
//         reader[j]->AddVariable( "mindr_lep2_jet", &varmindr_lep2_jet );
//         reader[j]->AddVariable( "numJets_float", &varnumJets_float );
//         reader[j]->AddVariable( "sum_jet_pt", &varsum_jet_pt );
//       }

      TString dir    = "../../simpleweights/" + label + "/"; //////
      TString prefix = "TMVAClassification";
      TString wfName = dir + prefix + TString("_CFMlpANN.weights.xml");

      std::cout << "Loading  weight file  " << wfName << std::endl; 
      
      // Book method(s)
      reader[j]->BookMVA( "CFMlpANN method", wfName);  

  }// end for each category 
  
  // Print out your config

  std::cout << "Using btag threshold " << btagThres << std::endl;
  
  // Creates a ChainEvent, allowing files to be linked   
  fwlite::ChainEvent ev(fileNames);   

  TFile histofile(outputFileName.c_str(),"recreate");

  histofile.cd();


  //////////////////////////////////////////////////////////////////////////
  ///  Booking Histograms
  //////////////////////////////////////////////////////////////////////////

//   // Book the histograms

  /////////////// split the nGen
  TH1D* h_nGen = new TH1D("h_nGen",";ttH decay", 9, 0, 9 );
  std::vector<std::string> ttHdecay_names;
  ttHdecay_names.push_back("2tWb");
  ttHdecay_names.push_back("qq_emu");
  ttHdecay_names.push_back("qq_emutau");
  ttHdecay_names.push_back("qq_emu_bb");
  ttHdecay_names.push_back("qq_emutau_bb");
  ttHdecay_names.push_back("2emu");
  ttHdecay_names.push_back("2emutau");
  ttHdecay_names.push_back("2emu_bb");
  ttHdecay_names.push_back("2emutau_bb");
  int numttHdecays = int(ttHdecay_names.size());

  for( int i=0; i<numttHdecays; i++ ){
    h_nGen->GetXaxis()->SetBinLabel(i+1,ttHdecay_names[i].c_str());
  }
  /////////////////

  
  ///////////////////////////////////////////////////////////////////
  //
  // Make a small tree called summaryTree that stores all your 
  // information event by events
  //
  ///////////////////////////////////////////////////////////////////

  bool CoreVariables = true;
  bool ExtraLeptonVariables = false;
  bool ExtraJetVariables = true;
  bool ExtraKinematicVariables = true;
  //bool ExtraEventVariables = false;
  bool ExtraTriggerVariables = false;
  bool ExtraGenVariables = true; //false;
  bool ExtraHiggsVariables = false;
  bool ExtraSameSignVariables = true;
  
  bool ArtificialJetPt = false;
  float higgs_mass = 115.0;
  
  std::map<TString, int *> intBranches;
  std::map<TString, unsigned int *> uintBranches;  
  std::map<TString, float *> floatBranches;

  // Core Variables
  if (CoreVariables) {

    //event variables
    intBranches["PassTwoLepton"] = new int (0);
    intBranches["TwoMuon"] = new int (0);
    intBranches["TwoEle"] = new int (0);
    intBranches["MuonEle"] = new int (0);

    intBranches["numMuons"] = new int (0);
    intBranches["numTightMuons"] = new int (0);
    intBranches["numLooseMuons"] = new int (0);
    intBranches["numSideMuons"] = new int (0);
    intBranches["numElectrons"] = new int (0);
    intBranches["numTightElectrons"] = new int (0);
    intBranches["numLooseElectrons"] = new int (0);
    intBranches["numSideElectrons"] = new int (0);

    intBranches["numJets"] = new int (0);
    intBranches["numTaggedJets"] = new int (0);
    intBranches["numLooseTaggedJets"] = new int (0);
    floatBranches["numJets_float"] = new float (0);
    floatBranches["numTaggedJets_float"] = new float (0);
    floatBranches["numLooseTaggedJets_float"] = new float (0);

    intBranches["isCleanEvent"] = new int (0);
    intBranches["isTriggerPass"] = new int (0);
    intBranches["isDoubleMuTriggerPass"] = new int (0);
    intBranches["isDoubleElectronTriggerPass"] = new int (0);
    intBranches["isMuEGTriggerPass"] = new int (0);
    intBranches["isMETTriggerPass"] = new int (0);

    intBranches["PassZmask"] = new int (0);
    intBranches["PassZmask2"] = new int (0);
    
    intBranches["oppositeLepCharge"] = new int (0);
    intBranches["oppositeGenLepCharge"] = new int (0);

    uintBranches["runNumber"] = new unsigned int (0);
    uintBranches["eventNumber"] = new unsigned int (0);
    uintBranches["luminosityBlock"] = new unsigned int (0);
    intBranches["sampleNumber"] = new int (0);
    
    /// MVA output variables
    floatBranches["CFMlpANN_e2je2t_v1"] = new float(0.0);
    floatBranches["CFMlpANN_e3je2t_v1"] = new float(0.0);
    floatBranches["CFMlpANN_ge4je2t_v1"] = new float(0.0);
    floatBranches["CFMlpANN_ge3t_v1"] = new float(0.0);
    floatBranches["CFMlpANN_ge3t_v2"] = new float(0.0);

    floatBranches["CFMlpANN_e2je2t_oldvar"] = new float(0.0);
    floatBranches["CFMlpANN_e3je2t_53x"] = new float(0.0);
    floatBranches["CFMlpANN_ge4je2t_53x"] = new float(0.0);
    floatBranches["CFMlpANN_ge3t_53x"] = new float(0.0);

//     floatBranches["CFMlpANN_eq3jeq3t_ttbar"] = new float(0.0);
//     floatBranches["CFMlpANN_ge4jge3t_ttbar"] = new float(0.0);
    floatBranches["CFMlpANN_SS_ge3jge0t_ttbar"] = new float(0.0);
//     floatBranches["CFMlpANN_SS_ge3jge1t_ttW"] = new float(0.0);

    //pile up
    floatBranches["numPV"] = new float(0.0);
    floatBranches["numTruePV"] = new float(0.0);
    floatBranches["numGenPV"] = new float(0.0);
    intBranches["numPartons"] = new int(0);
    
    //weights
    floatBranches["weight"] = new float(0.0);
    floatBranches["weight_PUup"] = new float(0.0);
    floatBranches["weight_PUdown"] = new float(0.0);
//     floatBranches["HtWgt"] = new float(0.0);
//     floatBranches["HtWgtUp"] = new float(0.0);
    floatBranches["Q2ScaleUpWgt"] = new float(0.0);
    floatBranches["Q2ScaleDownWgt"] = new float(0.0);
    floatBranches["lep1SF"] = new float (0.0);
    floatBranches["lep2SF"] = new float (0.0);
    floatBranches["lepTotalSF"] = new float (0.0);
    floatBranches["triggerSF"] = new float (0.0);
    //floatBranches["newSingleMuSF"] = new float (0.0);
    //floatBranches["newSingleEleSF"] = new float (0.0);
    //floatBranches["oldSingleMuSF"] = new float (0.0);
    //floatBranches["oldSingleEleSF"] = new float (0.0);
    
    floatBranches["weight_Xsec"] = new float(0.0);
    floatBranches["nGen"] = new float(0.0);
    floatBranches["Xsec"] = new float(0.0);
    floatBranches["topPtWgt"] = new float(0.0);
    floatBranches["topPtWgtUp"] = new float(0.0);
    floatBranches["csvWgtlf"] = new float(0.0);
    floatBranches["csvWgthf"] = new float(0.0);
    //// extra btag SFs weights
    floatBranches["csvWgtlf_HFUp"] = new float(0.0);
    floatBranches["csvWgtlf_HFDown"] = new float(0.0);
    floatBranches["csvWgtlf_Stats1Up"] = new float(0.0);
    floatBranches["csvWgtlf_Stats1Down"] = new float(0.0);
    floatBranches["csvWgtlf_Stats2Up"] = new float(0.0);
    floatBranches["csvWgtlf_Stats2Down"] = new float(0.0);

    floatBranches["csvWgthf_LFUp"] = new float(0.0);
    floatBranches["csvWgthf_LFDown"] = new float(0.0);
    floatBranches["csvWgthf_Stats1Up"] = new float(0.0);
    floatBranches["csvWgthf_Stats1Down"] = new float(0.0);
    floatBranches["csvWgthf_Stats2Up"] = new float(0.0);
    floatBranches["csvWgthf_Stats2Down"] = new float(0.0);
    //met
    floatBranches["met"] = new float(0.0);
    floatBranches["unc_met"] = new float(0.0);
    floatBranches["MHT"] = new float(0.0);

    //lepton variables
    floatBranches["lep1Pt"] = new float(0.0);
    floatBranches["lep2Pt"] = new float(0.0);
    floatBranches["lep1Eta"] = new float(0.0);
    floatBranches["lep2Eta"] = new float(0.0);
    floatBranches["maxLepEta"] = new float(0.0);
    floatBranches["maxLepAbsEta"] = new float(0.0);
    floatBranches["lep1Phi"] = new float(0.0);
    floatBranches["lep2Phi"] = new float(0.0);
    floatBranches["lep1Iso"] = new float(0.0);
    floatBranches["lep2Iso"] = new float(0.0);
    floatBranches["maxLepIso"] = new float(0.0);
    floatBranches["lep1TkCharge"] = new float (0.0);
    floatBranches["lep2TkCharge"] = new float (0.0);
    floatBranches["lep1GenCharge"] = new float (0.0);
    floatBranches["lep2GenCharge"] = new float (0.0);
    intBranches["lep1IsPrompt"] = new int (0);
    intBranches["lep2IsPrompt"] = new int (0);
    intBranches["lep1Flavor"] = new int (0);
    intBranches["lep2Flavor"] = new int (0);
    
    // jet variables
//     floatBranches["first_bjet_pt"] = new float(0.0);
    floatBranches["first_jet_pt"] = new float(0.0);
    floatBranches["second_jet_pt"] = new float(0.0);
    floatBranches["third_jet_pt"] = new float(0.0);
    floatBranches["fourth_jet_pt"] = new float(0.0);

    floatBranches["first_jet_eta"] = new float(0.0);
    floatBranches["second_jet_eta"] = new float(0.0);
    floatBranches["third_jet_eta"] = new float(0.0);
    floatBranches["fourth_jet_eta"] = new float(0.0);

    floatBranches["b1_jet_pt"] = new float(0.0);
    floatBranches["b2_jet_pt"] = new float(0.0);
    floatBranches["b1_jet_eta"] = new float(0.0);
    floatBranches["b2_jet_eta"] = new float(0.0);
    floatBranches["b1_jet_CSV"] = new float(0.0);
    floatBranches["b2_jet_CSV"] = new float(0.0);
    //kinematic variables
    ////ANN neural net inputs
//     floatBranches["mass_of_everything"] = new float(0.0);
    floatBranches["min_dr_tagged_jets"] = new float(0.0);
    floatBranches["mindr_lep1_jet"] = new float(0.0);
    floatBranches["mindr_lep2_jet"] = new float(0.0);
    floatBranches["avg_btag_disc_btags"] = new float(0.0);
    floatBranches["Ht"] = new float(0.0);

    floatBranches["higgsLike_dijet_mass"] = new float(0.0);
    floatBranches["higgsLike_dijet_mass2"] = new float(0.0);
    intBranches["numHiggsLike_dijet_15"] = new int (0.0);
    floatBranches["numHiggsLike_dijet_15_float"] = new float (0.0);

    ////leptons
    floatBranches["mass_leplep"] = new float(0.0);
    floatBranches["MT_leplep"] = new float(0.0);
    floatBranches["pt_leplep"] = new float(0.0);
    floatBranches["dPhi_leplep"] = new float(0.0);
    floatBranches["dR_leplep"] = new float(0.0);
    floatBranches["correctedDZ_leplep"] = new float(0.0);
    floatBranches["correctedD0_leplep"] = new float(0.0);
    floatBranches["tkDZ_leplep"] = new float(0.0);

    ////everything
    floatBranches["all_sum_pt"] = new float(0.0);
    floatBranches["sum_pt"] = new float(0.0); 
    floatBranches["sum_jet_pt"] = new float(0.0);
//     floatBranches["pt_of_everything"] = new float(0.0);
//     floatBranches["pz_of_everything"] = new float(0.0);
//      floatBranches["pt_of_ttbar"] = new float(0.0);

  } //End if (CoreVariables)

  if (ExtraSameSignVariables) {

//     floatBranches["lep1FlipSF"] = new float (0.0);
//     floatBranches["lep2FlipSF"] = new float (0.0);
    floatBranches["lepTotalFlipSF"] = new float (0.0);
//     floatBranches["lep1FlipSFUp"] = new float (0.0);
//     floatBranches["lep2FlipSFUp"] = new float (0.0);
    floatBranches["lepTotalFlipSFUp"] = new float (0.0);
//     floatBranches["lep1FlipSFDown"] = new float (0.0);
//     floatBranches["lep2FlipSFDown"] = new float (0.0);
    floatBranches["lepTotalFlipSFDown"] = new float (0.0);
//     floatBranches["lep1PromptSF"] = new float (0.0);
//     floatBranches["lep2PromptSF"] = new float (0.0);
    floatBranches["lepTotalPromptSF"] = new float (0.0);
//     floatBranches["lep1PromptSFUp"] = new float (0.0);
//     floatBranches["lep2PromptSFUp"] = new float (0.0);
    floatBranches["lepTotalPromptSFUp"] = new float (0.0);
//     floatBranches["lep1PromptSFDown"] = new float (0.0);
//     floatBranches["lep2PromptSFDown"] = new float (0.0);
    floatBranches["lepTotalPromptSFDown"] = new float (0.0);
//     intBranches["lep1PassSSCut"] = new int (0);
//     intBranches["lep2PassSSCut"] = new int (0);
    intBranches["lepTotalPassSSCut"] = new int (0);

    floatBranches["lep1GsfCharge"] = new float(0.0);
    floatBranches["lep2GsfCharge"] = new float(0.0);
    floatBranches["lep1ChargedIso"] = new float(0.0);
    floatBranches["lep2ChargedIso"] = new float(0.0);
    floatBranches["maxLepChargedIso"] = new float(0.0);
//     floatBranches["lep1NeutralIso"] = new float(0.0);
//     floatBranches["lep2NeutralIso"] = new float(0.0);
    floatBranches["lep1IP"] = new float(0.0);
    floatBranches["lep2IP"] = new float(0.0);
    floatBranches["lep1IPError"] = new float(0.0);
    floatBranches["lep2IPError"] = new float(0.0);
//     floatBranches["lep1dFracScEtTkPt"] = new float(0.0);
//     floatBranches["lep2dFracScEtTkPt"] = new float(0.0);

    floatBranches["mindr_lep1_allJet"] = new float(0.0);
    floatBranches["mindr_lep2_allJet"] = new float(0.0);
//     floatBranches["ptRel_lep1_jet"] = new float(0.0);
//     floatBranches["ptRel_lep2_jet"] = new float(0.0);
//     floatBranches["ptRel_lep1_allJet"] = new float(0.0);
//     floatBranches["ptRel_lep2_allJet"] = new float(0.0);


    floatBranches["wLike_dijet_mass_low1CSV"] = new float(0.0);
    floatBranches["wLike_dijet_mass_low2CSV"] = new float(0.0);
    floatBranches["wLike_dijet_pt_low1CSV"] = new float(0.0);
    floatBranches["wLike_dijet_pt_low2CSV"] = new float(0.0);
    floatBranches["wLike_dijet_eta_low1CSV"] = new float(0.0);
    floatBranches["wLike_dijet_eta_low2CSV"] = new float(0.0);
    floatBranches["topLike_trijet_mass_hiCSV_low1CSV"] = new float(0.0);
    floatBranches["topLike_trijet_mass_hiCSV_low2CSV"] = new float(0.0);
    floatBranches["topLike_trijet_mass_medTag_low1CSV"] = new float(0.0);
    floatBranches["topLike_trijet_mass_medTag_low2CSV"] = new float(0.0);
    floatBranches["topLike_trijet_mass_looseTag_low1CSV"] = new float(0.0);
    floatBranches["topLike_trijet_mass_looseTag_low2CSV"] = new float(0.0);
    floatBranches["topLike_dijet_lep1_mass_low1CSV"] = new float(0.0);
    floatBranches["topLike_dijet_lep1_mass_low2CSV"] = new float(0.0);
    floatBranches["topLike_dijet_lep2_mass_low1CSV"] = new float(0.0);
    floatBranches["topLike_dijet_lep2_mass_low2CSV"] = new float(0.0);
    floatBranches["MT_MHT_leplep"] = new float(0.0);
    floatBranches["mass_MHT_leplep"] = new float(0.0);
    floatBranches["MT_MHT_lep1"] = new float(0.0);
    floatBranches["MT_MHT_lep2"] = new float(0.0);
    floatBranches["MT_MHT_lep1_b1"] = new float(0.0);
    floatBranches["MT_MHT_lep1_b2"] = new float(0.0);
    floatBranches["MT_MHT_lep2_b1"] = new float(0.0);
    floatBranches["MT_MHT_lep2_b2"] = new float(0.0);
    floatBranches["MT_met_leplep"] = new float(0.0);
    floatBranches["mass_met_leplep"] = new float(0.0);
    floatBranches["MT_met_lep1"] = new float(0.0);
    floatBranches["MT_met_lep2"] = new float(0.0);
    floatBranches["MT_met_lep1_b1"] = new float(0.0);
    floatBranches["MT_met_lep1_b2"] = new float(0.0);
    floatBranches["MT_met_lep2_b1"] = new float(0.0);
    floatBranches["MT_met_lep2_b2"] = new float(0.0);
    floatBranches["mass_lep1_b1"] = new float(0.0);
    floatBranches["mass_lep2_b1"] = new float(0.0);
    floatBranches["mass_lep1_b2"] = new float(0.0);
    floatBranches["mass_lep2_b2"] = new float(0.0);
    floatBranches["dR_lep1_b1"] = new float(0.0);
    floatBranches["dR_lep2_b1"] = new float(0.0);
    floatBranches["dR_lep1_b2"] = new float(0.0);
    floatBranches["dR_lep2_b2"] = new float(0.0);
    
    intBranches["lep1GenMotherID"] = new int(0);
    intBranches["lep2GenMotherID"] = new int(0);
 
  }

  if (ExtraHiggsVariables) {
    
    intBranches["numHiggsJets"] = new int (0);
    intBranches["numHiggsAllJets"] = new int (0);
    intBranches["HiggsDecayMode"] = new int(0); //CC=4,BB=5,TT=6,GG=21,ZZ=23,WW=24
    floatBranches["higgs_pt"] = new float(0.0);
    floatBranches["higgs_pz"] = new float(0.0);
    floatBranches["higgs_genJet_mass"] = new float(0.0);
    floatBranches["higgs_genParton_mass"] = new float(0.0);
    floatBranches["higgsLike_diBjet_mass"] = new float(0.0);
    floatBranches["higgsLike_allDijet_mass"] = new float(0.0);
    floatBranches["higgsLike_dijet_dR"] = new float(0.0);
    floatBranches["higgsLike_dijet_pt"] = new float(0.0);
    floatBranches["higgsLike_dijet_eta"] = new float(0.0);
    floatBranches["higgsLike_dijet_jet1_pt"] = new float(0.0);
    floatBranches["higgsLike_dijet_jet2_pt"] = new float(0.0);
    intBranches["numHiggsLike_dijet_10"] = new int (0);
    intBranches["numHiggsLike_dijet_20"] = new int (0);
    intBranches["numHiggsLike_dijet_25"] = new int (0);
    intBranches["numHiggsLike_diBjet_10"] = new int (0);
    intBranches["numHiggsLike_diBjet_15"] = new int (0);
    intBranches["numHiggsLike_diBjet_20"] = new int (0);
    intBranches["numHiggsLike_diBjet_25"] = new int (0);
    floatBranches["numHiggsLike_dijet_10_float"] = new float (0.0);
    floatBranches["numHiggsLike_dijet_20_float"] = new float (0.0);
    floatBranches["numHiggsLike_dijet_25_float"] = new float (0.0);
    floatBranches["numHiggsLike_diBjet_10_float"] = new float (0.0);
    floatBranches["numHiggsLike_diBjet_15_float"] = new float (0.0);
    floatBranches["numHiggsLike_diBjet_20_float"] = new float (0.0);
    floatBranches["numHiggsLike_diBjet_25_float"] = new float (0.0);
    

    floatBranches["higgs_dijet_mass"] = new float(0.0);
    floatBranches["higgs_dijet_pt"] = new float(0.0);
    floatBranches["higgs_dijet_pz"] = new float(0.0);
    floatBranches["higgs_dijet_dR"] = new float(0.0);
    floatBranches["higgs_dijet_dPhi"] = new float(0.0);
    floatBranches["higgs_dijet_jet1_pt"] = new float(0.0);
    floatBranches["higgs_dijet_jet2_pt"] = new float(0.0);
    floatBranches["higgs_dijet_jet1_eta"] = new float(0.0);
    floatBranches["higgs_dijet_jet2_eta"] = new float(0.0);
    floatBranches["higgs_dijet_jet1_csv"] = new float(0.0);   
    floatBranches["higgs_dijet_jet2_csv"] = new float(0.0);   
//     floatBranches["higgs_dijet_jet1_Nconst"] = new float(0.0);
//     floatBranches["higgs_dijet_jet2_Nconst"] = new float(0.0);
//     floatBranches["higgs_dijet_jet1_btagSoftMuon"] = new float(0.0); 
//     floatBranches["higgs_dijet_jet2_btagSoftMuon"] = new float(0.0); 
//     floatBranches["higgs_dijet_jet1_btagSoftEle"] = new float(0.0); 
//     floatBranches["higgs_dijet_jet2_btagSoftEle"] = new float(0.0); 
//     floatBranches["higgs_dijet_jet1_leadCandPt"] = new float(0.0);  
//     floatBranches["higgs_dijet_jet2_leadCandPt"] = new float(0.0);  
//     floatBranches["higgs_dijet_jet1_leadCandDistFromPV"] = new float(0.0);   
//     floatBranches["higgs_dijet_jet2_leadCandDistFromPV"] = new float(0.0);
//     floatBranches["higgs_dijet_genJet1_pt"] = new float(0.0);
//     floatBranches["higgs_dijet_genJet2_pt"] = new float(0.0);
//     floatBranches["higgs_dijet_genParton1_pt"] = new float(0.0);
//     floatBranches["higgs_dijet_genParton2_pt"] = new float(0.0);
//     floatBranches["higgs_dijet_jet1_muon_dR"] = new float(0.0);
//     floatBranches["higgs_dijet_jet2_muon_dR"] = new float(0.0);
//     floatBranches["higgs_dijet_jet1_electron_dR"] = new float(0.0);
//     floatBranches["higgs_dijet_jet2_electron_dR"] = new float(0.0);
//     floatBranches["higgs_dijet_jet1_track_pt"] = new float(0.0);
//     floatBranches["higgs_dijet_jet2_track_pt"] = new float(0.0);
//     floatBranches["higgs_dijet_jet1_track_dR"] = new float(0.0);
//     floatBranches["higgs_dijet_jet2_track_dR"] = new float(0.0);
    
  } //End if (ExtraHiggsVariables)

  if (ExtraJetVariables) {
    
//     intBranches["numAllJets"] = new int(0);

//     floatBranches["first_jet_CHEF"] = new float(0.0);
//     floatBranches["second_jet_CHEF"] = new float(0.0);
//     floatBranches["third_jet_CHEF"] = new float(0.0);
//     floatBranches["fourth_jet_CHEF"] = new float(0.0);
//     floatBranches["sum_jet_CHEF"] = new float(0.0);

//     floatBranches["first_jet_charge"] = new float(0.0);
//     floatBranches["second_jet_charge"] = new float(0.0);
//     floatBranches["third_jet_charge"] = new float(0.0);
//     floatBranches["fourth_jet_charge"] = new float(0.0);

//     floatBranches["sum_jet_charge"] = new float(0.0);
//     floatBranches["sum_untagged_jet_charge"] = new float(0.0);
//     floatBranches["sum_tagged_jet_charge"] = new float(0.0);
//     floatBranches["leps_minus_jets_charge"] = new float(0.0);
//     floatBranches["leps_minus_untagged_jets_charge"] = new float(0.0);
//     floatBranches["leps_minus_tagged_jets_charge"] = new float(0.0);
  
    floatBranches["first_jet_CSV"] = new float(0.0);
    floatBranches["second_jet_CSV"] = new float(0.0);
    floatBranches["third_jet_CSV"] = new float(0.0);
    floatBranches["fourth_jet_CSV"] = new float(0.0);

//     floatBranches["first_lf_jet_pt"] = new float(0.0);
//     floatBranches["first_lf_jet_eta"] = new float(0.0);
//     floatBranches["first_lf_jet_CSV_unshaped"] = new float(0.0);
//     floatBranches["first_lf_jet_CSV_reshaped"] = new float(0.0);

//     floatBranches["first_hf_jet_pt"] = new float(0.0);
//     floatBranches["first_hf_jet_eta"] = new float(0.0);
//     floatBranches["first_hf_jet_CSV_unshaped"] = new float(0.0);
//     floatBranches["first_hf_jet_CSV_reshaped"] = new float(0.0);

//     floatBranches["first_allJet_pt"] = new float(0.0);
//     floatBranches["second_allJet_pt"] = new float(0.0);
//     floatBranches["third_allJet_pt"] = new float(0.0);
//     floatBranches["fourth_allJet_pt"] = new float(0.0);

//     floatBranches["first_dibjet_mass"] = new float(0.0);
//     floatBranches["second_dibjet_mass"] = new float(0.0);
//     floatBranches["third_dibjet_mass"] = new float(0.0);
//     floatBranches["lowest_dibjet_mass"] = new float(0.0);
    
//     floatBranches["first_untagged_dijet_mass"] = new float(0.0);
//     floatBranches["second_untagged_dijet_mass"] = new float(0.0);
//     floatBranches["third_untagged_dijet_mass"] = new float(0.0);
//     floatBranches["lowest_untagged_dijet_mass"] = new float(0.0);
    
     floatBranches["dijet_mass_m2H"] = new float(0.0);
     floatBranches["dijet_mass_first"] = new float(0.0);
//     floatBranches["dijet_mass_second"] = new float(0.0);
     floatBranches["dijet_mass_third"] = new float(0.0);
//     floatBranches["dijet_mass_lowest"] = new float(0.0);

//     floatBranches["min_dr_genB1_allJet"] = new float (0.0);
//     floatBranches["min_dr_genB2_allJet"] = new float (0.0);

//     floatBranches["CSV_30to45_0p0to1p2_1"] = new float(0.0);
//     floatBranches["CSV_45to75_0p0to1p2_1"] = new float(0.0);
//     floatBranches["CSV_75to150_0p0to1p2_1"] = new float(0.0);
//     floatBranches["CSV_150toInf_0p0to1p2_1"] = new float(0.0);
//     floatBranches["CSV_30to45_1p2to2p1_1"] = new float(0.0);
//     floatBranches["CSV_45to75_1p2to2p1_1"] = new float(0.0);
//     floatBranches["CSV_75to150_1p2to2p1_1"] = new float(0.0);
//     floatBranches["CSV_150toInf_1p2to2p1_1"] = new float(0.0);
//     floatBranches["CSV_30to45_2p1to2p4_1"] = new float(0.0);
//     floatBranches["CSV_45to75_2p1to2p4_1"] = new float(0.0);
//     floatBranches["CSV_75to150_2p1to2p4_1"] = new float(0.0);
//     floatBranches["CSV_150toInf_2p1to2p4_1"] = new float(0.0);

//     floatBranches["CSV_30to45_0p0to1p2_2"] = new float(0.0);
//     floatBranches["CSV_45to75_0p0to1p2_2"] = new float(0.0);
//     floatBranches["CSV_75to150_0p0to1p2_2"] = new float(0.0);
//     floatBranches["CSV_150toInf_0p0to1p2_2"] = new float(0.0);
//     floatBranches["CSV_30to45_1p2to2p1_2"] = new float(0.0);
//     floatBranches["CSV_45to75_1p2to2p1_2"] = new float(0.0);
//     floatBranches["CSV_75to150_1p2to2p1_2"] = new float(0.0);
//     floatBranches["CSV_150toInf_1p2to2p1_2"] = new float(0.0);
//     floatBranches["CSV_30to45_2p1to2p4_2"] = new float(0.0);
//     floatBranches["CSV_45to75_2p1to2p4_2"] = new float(0.0);
//     floatBranches["CSV_75to150_2p1to2p4_2"] = new float(0.0);
//     floatBranches["CSV_150toInf_2p1to2p4_2"] = new float(0.0);

  } //End if (ExtraJetVariables)

  if (ExtraTriggerVariables) {
    
    intBranches["isTriggerPassPrescaled"] = new int (0);
    intBranches["isDoubleMuTriggerPS0"] = new int (0);
    intBranches["isDoubleElectronTriggerPS0"] = new int (0);
    intBranches["isMuEGTriggerPS0"] = new int (0);
    intBranches["isMETTriggerPS0"] = new int (0);

    intBranches["isDoubleMu7Pass"] = new int (0);
    intBranches["isMu8Pass"] = new int (0);
    intBranches["isMu13_Mu8Pass"] = new int (0);
    intBranches["isMu17_Mu8Pass"] = new int (0);
    intBranches["isMu17_TkMu8Pass"] = new int (0);
    intBranches["isMu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVLPass"] = new int (0);
    intBranches["isMu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVLPass"] = new int (0);
    intBranches["isEle17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVLPass"] = new int (0);
    intBranches["isMu22_Photon22_CaloIdLPass"] = new int (0);
    intBranches["isMu30_Ele30_CaloIdLPass"] = new int (0);
    intBranches["isEle8_CaloIdL_CaloIsoVLPass"] = new int (0);
    intBranches["isDiCentralPFJet30_PFMET80_BTagCSV07Pass"] = new int(0);
    intBranches["isMET120_HBHENoiseCleanedPass"] = new int(0);
    intBranches["isMET200Pass"] = new int(0);
    intBranches["isPFMET150Pass"] = new int(0);

  } //End if (ExtraTriggerVariables)

  if (ExtraGenVariables) {
    
    intBranches["lep1GenID"] = new int(0);
    intBranches["lep2GenID"] = new int(0);
    intBranches["first_jet_genID"] = new int(0);
    intBranches["second_jet_genID"] = new int(0);
    intBranches["third_jet_genID"] = new int(0);
    intBranches["fourth_jet_genID"] = new int(0);
    intBranches["first_jet_flavor"] = new int(0);
    intBranches["second_jet_flavor"] = new int(0);
    intBranches["third_jet_flavor"] = new int(0);
    intBranches["fourth_jet_flavor"] = new int(0);
//     floatBranches["top1_pt"] = new float(0.0);
//     floatBranches["top1_pz"] = new float(0.0);

  } //End if (ExtraGenVariables)

  if (ExtraKinematicVariables) {
    ////objects
    //floatBranches["topLike_trijet_mass"] = new float(0.0);
//     floatBranches["m2H_btag"] = new float(0.0);
//     floatBranches["wLike_allDijet_mass"] = new float(0.0);
//     floatBranches["topLike_allTrijet_mass"] = new float(0.0);

    ////leptons
//     floatBranches["dEta_leplep"] = new float(0.0);
//     floatBranches["MT_met_lep1"] = new float(0.0);
//     floatBranches["MT_met_lep2"] = new float(0.0);
//     floatBranches["dPhi_met_lep1"] = new float(0.0);
//     floatBranches["dPhi_met_lep2"] = new float(0.0);
    ////everything
//     intBranches["PassZmask3"] = new int (0);
    
    floatBranches["min_dr_jets"] = new float(0.0);
    floatBranches["avg_dr_jets"] = new float(0.0);    
    floatBranches["avg_dr_tagged_jets"] = new float(0.0);
    
    floatBranches["avg_tagged_dijet_mass"] = new float(0.0);
//     floatBranches["avg_untagged_dijet_mass"] = new float(0.0);
    floatBranches["avg_dijet_mass"] = new float(0.0);
//     floatBranches["M2_of_closest_jets"] = new float(0.0);
//     floatBranches["M2_of_closest_tagged_jets"] = new float(0.0);
//     floatBranches["closest_dijet_mass"] = new float(0.0);
//     floatBranches["closest_tagged_dijet_mass"] = new float(0.0);
    
    floatBranches["avg_btag_disc_non_btags"] = new float(0.0);
    floatBranches["highest_btag_disc_non_btags"] = new float(0.0);
//     floatBranches["dev_from_avg_disc_btags"] = new float(0.0);
//     floatBranches["first_highest_btag"] = new float(0.0);
//     floatBranches["second_highest_btag"] = new float(0.0);
//     floatBranches["lowest_btag"] = new float(0.0);

//     floatBranches["mass_MHT"] = new float(0.0);
//     floatBranches["mass_of_leps_and_allJets"] = new float(0.0);
//     floatBranches["pt_of_leps_and_allJets"] = new float(0.0);
//     floatBranches["pt_of_allEverything"] = new float(0.0);
    //floatBranches["pt_total"] = new float(0.0);
    
  } //End if (ExtraKinematicVariables)


  if (ExtraLeptonVariables) {
    
  intBranches["lep2IsGlobalMuon"] = new int (0);
  intBranches["lep2IsTrackerMuon"] = new int (0);  
  intBranches["lep2IsGlobalMuonPromptTight"] = new int (0);  
  intBranches["lep2NumTrackHits"] = new int (0);  
  intBranches["lep2NumPixelHits"] = new int (0);  
  intBranches["lep2NumberOfMatches"] = new int (0);  
  floatBranches["lep2Chi2"] = new float (0.0);
  intBranches["lep2NumExpectedHits"] = new int (0);

  } //End if (ExtraLeptonVariables)

  ////////////////////  
  histofile.cd();


  TTree * summaryTree = new TTree ("summaryTree", "Summary Event Values");

  for (std::map<TString, int*>::iterator iBranchMap = intBranches.begin();
       iBranchMap != intBranches.end();
       iBranchMap ++) {

    cout << "Creating branch  " << (iBranchMap->first).Data() << endl;
    TString tempTreeType = iBranchMap->first;
    tempTreeType += "/I";
    summaryTree->Branch(iBranchMap->first, iBranchMap->second, tempTreeType);

  }

  for (std::map<TString, unsigned int *>::iterator uBranchMap = uintBranches.begin();
       uBranchMap != uintBranches.end();
       uBranchMap ++) {

    cout << "Creating branch  " << (uBranchMap->first).Data() << endl;
    TString tempTreeType = uBranchMap->first;
    tempTreeType += "/i";
    summaryTree->Branch(uBranchMap->first, uBranchMap->second, tempTreeType);

  }

  ////Robin 
  for (std::map<TString, float*>::iterator iDMap = floatBranches.begin();
       iDMap != floatBranches.end();
       iDMap ++) {
    
    std::cout << "Creating branch   " << (iDMap->first).Data() << endl;
    TString ttString = iDMap->first;
    ttString += "/F";
    summaryTree->Branch(iDMap->first, iDMap->second, ttString);       
  }

  //////////////////////////////////////////////////////////////////////////
  ///  Event variables
  //////////////////////////////////////////////////////////////////////////

  ////// ============== trigger ===========
  vstring mc_hlt_DoubleMu_trigger_collection;
  vstring mc_hlt_DoubleElectron_trigger_collection;
  vstring mc_hlt_MuEG_trigger_collection;
  vstring mc_hlt_MET_trigger_collection;

  if( selectionYearStr == "2011"){
    mc_hlt_DoubleMu_trigger_collection.push_back("HLT_DoubleMu7_v");
    mc_hlt_DoubleMu_trigger_collection.push_back("HLT_Mu13_Mu8_v");
    mc_hlt_DoubleMu_trigger_collection.push_back("HLT_Mu17_Mu8_v");
    
    mc_hlt_DoubleElectron_trigger_collection.push_back("HLT_Ele17_CaloIdL_CaloIsoVL_Ele8_CaloIdL_CaloIsoVL_v");
    mc_hlt_DoubleElectron_trigger_collection.push_back("HLT_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v");
    mc_hlt_DoubleElectron_trigger_collection.push_back("HLT_Ele17_CaloIdT_TrkIdVL_CaloIsoVL_TrkIsoVL_Ele8_CaloIdT_TrkIdVL_CaloIsoVL_TrkIsoVL_v");
    
    mc_hlt_MuEG_trigger_collection.push_back("HLT_Mu17_Ele8_CaloIdL_v");
    mc_hlt_MuEG_trigger_collection.push_back("HLT_Mu8_Ele17_CaloIdL_v");
    mc_hlt_MuEG_trigger_collection.push_back("HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_v");
    mc_hlt_MuEG_trigger_collection.push_back("HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_v");
  }
  else if( selectionYearStr == "2012_52x" || selectionYearStr == "2012_53x") {
    mc_hlt_DoubleMu_trigger_collection.push_back("HLT_Mu17_Mu8_v");
    mc_hlt_DoubleMu_trigger_collection.push_back("HLT_Mu17_TkMu8_v");
    mc_hlt_DoubleElectron_trigger_collection.push_back("HLT_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v");
    mc_hlt_MuEG_trigger_collection.push_back("HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v");
    mc_hlt_MuEG_trigger_collection.push_back("HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v");
    mc_hlt_MET_trigger_collection.push_back("HLT_DiCentralPFJet30_PFMET80_BTagCSV07_v");
    mc_hlt_MET_trigger_collection.push_back("HLT_MET120_HBHENoiseCleaned_v");
    mc_hlt_MET_trigger_collection.push_back("HLT_MET200_v");
    mc_hlt_MET_trigger_collection.push_back("HLT_PFMET150_v");
  }
  else {
    assert (selectionYearStr == "either 2012_52x, 2012_53x, or 2011");
  } 

  ///
  float minNDOF = 4;
  float maxAbsZ = 24;
  float maxd0   = 2.;

  int nevents=0;
  float nevents_wgt=0;

  int nentries = ev.size();
  std::cout << "\n\t Number of entries = " << nentries << std::endl;
  std::cout << "\t Max number of entries = " << maxNentries << std::endl;
  std::cout << "\n" << std::endl;

  int cnt = 0;

  bool verbose = false;
  
  //
  // Loop over events
  //
  std::cout << "========  Starting Event Loop  ========" << std::endl;
  try {
    for( ev.toBegin(); !ev.atEnd(); ++ev) {

      cnt++;

      if( cnt==1 )        std::cout << "     Event " << cnt << std::endl;
      if( cnt%10000==0 && cnt!=1 ) std::cout << "Helper events " << cnt << "\t" 
					      << int(float(cnt)/float(nentries)*100) << "% done" << std::endl;

      if( cnt==(maxNentries+1) ) break;

      // initialize tree values 
      for (std::map<TString, int*>::iterator iBranchMap = intBranches.begin();
           iBranchMap != intBranches.end();
           iBranchMap ++) {
        // the memory address whose pointer we've saved should be initialized
        // to -1
        *(iBranchMap->second) = -1;
      }

      for (std::map<TString, unsigned int*>::iterator uBranchMap = uintBranches.begin();
             uBranchMap != uintBranches.end();
           uBranchMap ++) {
        *(uBranchMap->second) = 0;
      }
      
      ////Robin
      for (std::map<TString, float*>::iterator iDMap = floatBranches.begin();
	   iDMap != floatBranches.end();
	   iDMap ++) {
        * (iDMap->second)  = -9.99e3;
      }

      if (verbose) std::cout << "Getting collections... " <<std::endl;
      //std::cout << "========  Event! ========" << std::endl;
      // Get Handle for each collection used
      fwlite::Handle<BNeventCollection> h_event;
      h_event.getByLabel(ev,"BNproducer");
      BNeventCollection const &events = *h_event;

      fwlite::Handle<BNmuonCollection> h_muons;
      if ( selectionYearStr == "2012_52x" || selectionYearStr == "2012_53x" ) h_muons.getByLabel(ev,"BNproducer","selectedPatMuonsPFlow");
      else h_muons.getByLabel(ev,"BNproducer","selectedPatMuonsLoosePFlow");
      BNmuonCollection const &muons = *h_muons;

      fwlite::Handle<BNmuonCollection> h_muons_loose;
      if ( selectionYearStr == "2011" ) h_muons_loose.getByLabel(ev,"BNproducer","selectedPatMuonsLoosePFlow");
      else if ( selectionYearStr == "2012_53x" ) h_muons_loose.getByLabel(ev,"BNproducer","selectedPatMuonsLoosePFlow");
      else if ( selectionYearStr == "2012_52x" ) h_muons_loose.getByLabel(ev,"BNproducer","selectedPatMuonsPFlow");
      else assert ( selectionYearStr == "2012_52x, 2012_53x, or 2011" );
      BNmuonCollection const &looseMuons = *h_muons_loose;
      
      fwlite::Handle<BNmetCollection> h_pfmet;
      if ( selectionYearStr == "2011" ) h_pfmet.getByLabel(ev,"BNproducer","patMETsTypeIPFlow");
      else if ( selectionYearStr == "2012_52x" || selectionYearStr == "2012_53x" ) h_pfmet.getByLabel(ev,"BNproducer","patMETsPFlow");
      else assert (selectionYearStr == "either 2012_52x, 2012_53x, or 2011");
      BNmetCollection const &pfmets = *h_pfmet;

      fwlite::Handle<BNtriggerCollection> h_hlt;
      h_hlt.getByLabel(ev,"BNproducer","HLT");
      BNtriggerCollection const &hlt = *h_hlt;

      fwlite::Handle<BNprimaryvertexCollection> h_pvs;
      h_pvs.getByLabel(ev,"BNproducer","offlinePrimaryVertices");
      BNprimaryvertexCollection const &pvs = *h_pvs;

      fwlite::Handle<BNjetCollection> h_pfjets;
      h_pfjets.getByLabel(ev,"BNproducer","selectedPatJetsPFlow");
      BNjetCollection const &pfjets = *h_pfjets;

      fwlite::Handle<BNelectronCollection> h_electrons;
      if ( selectionYearStr == "2012_52x" || selectionYearStr == "2012_53x" ) h_electrons.getByLabel(ev,"BNproducer","selectedPatElectronsPFlow");
      else h_electrons.getByLabel(ev,"BNproducer","selectedPatElectronsLoosePFlow");
      BNelectronCollection const &electrons = *h_electrons;

      fwlite::Handle<BNelectronCollection> h_electrons_loose;
      if ( selectionYearStr == "2011" ) h_electrons_loose.getByLabel(ev,"BNproducer","selectedPatElectronsLoosePFlow");
      else if ( selectionYearStr == "2012_53x" ) h_electrons_loose.getByLabel(ev,"BNproducer","selectedPatElectronsLoosePFlow");
      else if ( selectionYearStr == "2012_52x" ) h_electrons_loose.getByLabel(ev,"BNproducer","selectedPatElectronsPFlow");
      else assert ( selectionYearStr == "2012_52x, 2012_53x, or 2011" );
      BNelectronCollection const &looseElectrons = *h_electrons_loose;
      
      fwlite::Handle<BNmcparticleCollection> h_mcparticles;
      h_mcparticles.getByLabel(ev,"BNproducer","MCstatus3");
      BNmcparticleCollection const &mcparticles = *h_mcparticles;

      //fwlite::Handle<BNtrigobjCollection> h_hltobj;
      //h_hltobj.getByLabel(ev,"BNproducer","HLT");
      //BNtrigobjCollection const &hltobjs = *h_hltobj;

      if (verbose) std::cout << "Getting collections... " <<std::endl;

      // Some of the other collections in the tree that are not used here

      // fwlite::Handle<BNmuonCollection> h_muons;
      // h_muons.getByLabel(ev,"BNproducer","selectedPatMuons");
      // BNmuonCollection const &muons = *h_muons;

      // fwlite::Handle<BNmetCollection> h_calomet;
      // h_calomet.getByLabel(ev,"BNproducer","patMETsAK5Calo");
      // BNmetCollection const &calomets = *h_calomet;

      // fwlite::Handle<BNmetCollection> h_tcmet;
      // h_tcmet.getByLabel(ev,"BNproducer","patMETsTC");
      // BNmetCollection const &tcmets = *h_tcmet;

      // fwlite::Handle<BNmcparticleCollection> h_mcparticles;
      // h_mcparticles.getByLabel(ev,"BNproducer","MCstatus3");
      // BNmcparticleCollection const &mcparticles = *h_mcparticles;

      // fwlite::Handle<BNtriggerCollection> h_l1talgo;
      // h_l1talgo.getByLabel(ev,"BNproducer","L1Talgo");
      // BNtriggerCollection const &l1talgo = *h_l1talgo;

      // fwlite::Handle<BNtrigobjCollection> h_l1tmuonobj;
      // h_l1tmuonobj.getByLabel(ev,"BNproducer","L1MuonParticles");
      // BNtrigobjCollection const &l1tmuonobjs = *h_l1tmuonobj;

      fwlite::Handle<BNtrackCollection> h_tracks;
      h_tracks.getByLabel(ev,"BNproducer","generalTracks");
      BNtrackCollection const &tracks = *h_tracks;

      // fwlite::Handle<BNjetCollection> h_calojets;
      // h_calojets.getByLabel(ev,"BNproducer","selectedPatJetsAK5Calo");
      // BNjetCollection const &calojets = *h_calojets;

      // fwlite::Handle<BNmcparticleCollection> h_mcelectrons;
      // h_mcelectrons.getByLabel(ev,"BNproducer","MCeleStatus1");
      // BNmcparticleCollection const &mcelectrons = *h_mcelectrons;

      // fwlite::Handle<BNphotonCollection> h_photons;
      // h_photons.getByLabel(ev,"BNproducer","selectedPatPhotons");
      // BNphotonCollection const &photons = *h_photons;

      /////////
      ///
      /// Event / MET
      ///
      ////////

      EventIter event = events.begin();

      int eventSampleNumber = event->sample;

      double numTruePV = event->numTruePV;
      double numGenPV = event->numGenPV;

      float Q2ScaleUpWgt = 1.0;
      float Q2ScaleDownWgt = 1.0; 

      if ( sampleName == "ttbar" || tmpName.Contains("ttbar_") ) {
        Q2ScaleUpWgt = event->Q2ScaleUpWgt;
        Q2ScaleDownWgt = event->Q2ScaleDownWgt;
      }

      /// top pt reweighting
      double topPtWgt = 1.;
      double topPtWgtUp = 1.;
      topPtWgt = beanHelper.GetTopPtweight(mcparticles);
      topPtWgtUp = 2*(topPtWgt-1) + 1;
      if(cnt<5)  std::cout << "CONFIG: topPt rwt is: " << topPtWgt << std::endl;
      /////
      
      float weight = 1.0 ;

      if(cnt<5)  std::cout << "CONFIG: Sample number from ntuple is: " << eventSampleNumber << std::endl;

     //// specific to ttH signal sample???
      int HtoBB = 0;
      int HtoCC = 0;
      int HtoTT = 0;
      int HtoGG = 0;
      int HtoWW = 0;
      int HtoZZ = 0;
      
      float higgs_pt = dFloat;
      float higgs_pz = dFloat;
      float top1_pt = dFloat;
      float top1_pz = dFloat;

      vfloat muon_px;
      vfloat ele_px;
      vfloat muon_py;
      vfloat ele_py;
      vfloat muon_pz;
      vfloat ele_pz;
      vint muon_mother;
      vint ele_mother;
      vint muon_grandmother;
      vint ele_grandmother;
      
      TLorentzVector higgsGenBV[2];
        //std::cout << "Event: " << cnt << std::endl;
      for( unsigned i=0; i< mcparticles.size(); i++ ){
        int Aid = mcparticles.at(i).id;
        int AmotherID = mcparticles.at(i).motherId;
        int AgrandMotherID = mcparticles.at(i).grandMotherId;
        if ((Aid == 5 || Aid == -5) && AmotherID == 25) {
          if (HtoBB == 1) higgsGenBV[0].SetPtEtaPhiE(mcparticles.at(i).pt,mcparticles.at(i).eta,mcparticles.at(i).phi,mcparticles.at(i).energy);
          else higgsGenBV[1].SetPtEtaPhiE(mcparticles.at(i).pt,mcparticles.at(i).eta,mcparticles.at(i).phi,mcparticles.at(i).energy);
          HtoBB = 1;
        }
        if ((Aid == 4 || Aid == -4) && AmotherID == 25) HtoCC = 1;
        if ((Aid == 15 || Aid == -15) && AmotherID == 25) HtoTT = 1;  
        if ((Aid == 21 || Aid == -21) && AmotherID == 25) HtoGG = 1;  
        if ((Aid == 23 || Aid == -23) && AmotherID == 25) HtoZZ = 1;  
        if ((Aid == 24 || Aid == -24) && AmotherID == 25) HtoWW = 1;  

        if ((Aid == 11 || Aid == -11) && (AmotherID != 11 && AmotherID != -11 && AgrandMotherID != 11 && AgrandMotherID != -11)) {
          ele_px.push_back(mcparticles.at(i).px);
          ele_py.push_back(mcparticles.at(i).py);
          ele_pz.push_back(mcparticles.at(i).pz);
          ele_mother.push_back(AmotherID);
          ele_grandmother.push_back(AgrandMotherID);
        }
        if ((Aid == 13 || Aid == -13) && (AmotherID != 13 && AmotherID != -13 && AgrandMotherID != 13 && AgrandMotherID != -13)) {
          muon_px.push_back(mcparticles.at(i).px);
          muon_py.push_back(mcparticles.at(i).py);
          muon_pz.push_back(mcparticles.at(i).pz);
          muon_mother.push_back(AmotherID);
          muon_grandmother.push_back(AgrandMotherID);
        }

        if  (Aid == 25) {
          higgs_pt = mcparticles.at(i).pt;
          higgs_pz = mcparticles.at(i).pz;
        }
        if (Aid == 6 || Aid == -6) {
          top1_pt = mcparticles.at(i).pt;
          top1_pz = mcparticles.at(i).pz;
        }
        //std::cout << "Particle " << i << " is " << Aid << ", has mother " << AmotherID << " and grandmother " << AgrandMotherID << std::endl;

      }

      if( (sampleName == "ttbar" || tmpName.Contains("ttbar_" )) && !tmpName.Contains("ttbar_scale") && !tmpName.Contains("ttbar_matching")) {       
        
        bool keepEvent = false;

        keepEvent = beanHelper.ttPlusHeavyKeepEvent (mcparticles, pfjets );

        if(!keepEvent) continue;
      }// end if you are a top sample

      //-------------------------------------
      //-------------------------------------

      if (verbose) std::cout << "met stuff " <<std::endl;
      
      MetIter pfmet = pfmets.begin();
      BNmet pfmetSelected = beanHelper.GetCorrectedMET(pfmets.at(0),pfjets,iSysType);
      
      // Loop over and count the number of primary vertices
      int numPV = 0;
      for( int i=0; i<int(pvs.size()); i++ ){
        bool isGood = ( (pvs.at(i).ndof>=minNDOF) &&
                        (fabs(pvs.at(i).z)<maxAbsZ) &&
                        (fabs(pvs.at(i).rho)<maxd0) );
        bool isFake = ( pvs.at(i).isFake==1 );
        if( isGood && !isFake ) numPV++;
      }

      if (verbose) std::cout << "about to do pu reweight " <<std::endl;
      ///--------------------------------
      // Pile-up reweighting  ////Robin
      double weight_PUnominal = 1.0;
      double weight_PUup = 1.0;
      double weight_PUdown = 1.0;

      if(!isData){
        if(selectionYearStr == "2011") {
          if ((TString(sampleName).Contains("ttH")) || (sampleName=="ttbarW") || (sampleName=="ttbarZ")) {
            weight_PUnominal = beanHelper.GetPUweight(numGenPV);
            weight_PUup = beanHelper.GetPUweightUp(numGenPV);
            weight_PUdown = beanHelper.GetPUweightDown(numGenPV);
          }
          else {
            weight_PUnominal = beanHelper.GetPUweight(numTruePV);
            weight_PUup = beanHelper.GetPUweightUp(numTruePV);
            weight_PUdown = beanHelper.GetPUweightDown(numTruePV);
          }
        }
        else if(selectionYearStr == "2012_52x" || selectionYearStr == "2012_53x") {
          weight_PUnominal = beanHelper.GetPUweight(numTruePV);
          weight_PUup = beanHelper.GetPUweightUp(numTruePV);
          weight_PUdown = beanHelper.GetPUweightDown(numTruePV);
        }
        else {
          assert (selectionYearStr == "either 2012_52x, 2012_53x, or 2011");
        }
      }
      weight *= weight_PUnominal;


      ///--------------------------------
      // Trigger Requirement
      bool triggerFound = false;
      bool DoubleMuTriggerFound = false;
      bool DoubleElectronTriggerFound = false;
      bool MuEGTriggerFound = false;
      bool METTriggerFound = false;
      bool isTriggerPass = false;
      bool isTriggerPassPrescaled = false;
      bool isDoubleMuTriggerPass = false;
      bool isDoubleElectronTriggerPass = false;
      bool isMuEGTriggerPass = false;
      bool isMETTriggerPass = false;
      bool isDoubleMuTriggerPS0 = false;
      bool isDoubleElectronTriggerPS0 = false;
      bool isMuEGTriggerPS0 = false;
      bool isMETTriggerPS0 = false;
      bool HLT_DoubleMu7_v = false;
      bool HLT_Mu8_v = false;
      bool HLT_Mu13_Mu8_v = false;
      bool HLT_Mu17_Mu8_v = false;
      bool HLT_Mu17_TkMu8_v = false;
      bool HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v = false;
      bool HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v = false;
      bool HLT_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v = false;
      bool HLT_Ele8_CaloIdL_CaloIsoVL_v = false;
      bool HLT_Mu22_Photon22_CaloIdL_v = false;
      bool HLT_Mu30_Ele30_CaloIdL_v = false;
      bool HLT_DiCentralPFJet30_PFMET80_BTagCSV07_v = false;
      bool HLT_MET120_HBHENoiseCleaned_v = false;
      bool HLT_MET200_v = false;
      bool HLT_PFMET150_v = false;
      if (verbose) std::cout << "about to do pu reweight " <<std::endl;
      //      if( eventSampleNumber>=0 ){
      std::string hlt_name = "holder";

	for( TrigIter hltbit = hlt.begin(); hltbit != hlt.end(); ++hltbit ) {
      hlt_name = hltbit->name;
      if(hlt_name.find("HLT_Mu8_v")!=std::string::npos) HLT_Mu8_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_DoubleMu7_v")!=std::string::npos) HLT_DoubleMu7_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_Mu13_Mu8_v")!=std::string::npos) HLT_Mu13_Mu8_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_Mu17_Mu8_v")!=std::string::npos) HLT_Mu17_Mu8_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_Mu17_TkMu8_v")!=std::string::npos) HLT_Mu17_TkMu8_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v")!=std::string::npos) HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v")!=std::string::npos) HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v")!=std::string::npos) HLT_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_Ele8_CaloIdL_CaloIsoVL_v")!=std::string::npos) HLT_Ele8_CaloIdL_CaloIsoVL_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_Mu22_Photon22_CaloIdL_v")!=std::string::npos) HLT_Mu22_Photon22_CaloIdL_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_Mu30_Ele30_CaloIdL_v")!=std::string::npos) HLT_Mu30_Ele30_CaloIdL_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_DiCentralPFJet30_PFMET80_BTagCSV07_v")!=std::string::npos) HLT_DiCentralPFJet30_PFMET80_BTagCSV07_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_MET120_HBHENoiseCleaned_v")!=std::string::npos) HLT_MET120_HBHENoiseCleaned_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_MET200_v")!=std::string::npos) HLT_MET200_v = ( hltbit->pass==1 );
      if(hlt_name.find("HLT_PFMET150_v")!=std::string::npos) HLT_PFMET150_v = ( hltbit->pass==1 );

      for( int t=0; t<int(mc_hlt_DoubleMu_trigger_collection.size()); t++ ){
        //hlt_name = hltbit->name;
	    if( (hlt_name.find(mc_hlt_DoubleMu_trigger_collection[t])!=std::string::npos) ) {
	      if( hltbit->prescale==1 || hltbit->prescale==0 ) {
            DoubleMuTriggerFound = true;
            isDoubleMuTriggerPass = ( ( hltbit->pass==1 && hltbit->prescale==1 ) || isDoubleMuTriggerPass);
            isDoubleMuTriggerPS0 = ( ( hltbit->prescale==0 ) || isDoubleMuTriggerPS0);
          }
          else isTriggerPassPrescaled = ( hltbit->pass==1 || isTriggerPassPrescaled);
        }
        if( isDoubleMuTriggerPass ) break;
      }
      for( int t=0; t<int(mc_hlt_DoubleElectron_trigger_collection.size()); t++ ){
        //hlt_name = hltbit->name;
	    if( (hlt_name.find(mc_hlt_DoubleElectron_trigger_collection[t])!=std::string::npos) ) {
	      if( hltbit->prescale==1 || hltbit->prescale==0 ) {
            DoubleElectronTriggerFound = true;
            isDoubleElectronTriggerPass = ( ( hltbit->pass==1 && hltbit->prescale==1 ) || isDoubleElectronTriggerPass);
            isDoubleElectronTriggerPS0 = ( ( hltbit->prescale==0 ) || isDoubleElectronTriggerPS0);
          }
          else isTriggerPassPrescaled = ( hltbit->pass==1 || isTriggerPassPrescaled);
        }
        if( isDoubleElectronTriggerPass ) break;
      }
      for( int t=0; t<int(mc_hlt_MuEG_trigger_collection.size()); t++ ){
        //hlt_name = hltbit->name;
	    if( (hlt_name.find(mc_hlt_MuEG_trigger_collection[t])!=std::string::npos) ) {
	      if( hltbit->prescale==1 || hltbit->prescale==0 ) {
            MuEGTriggerFound = true;
            isMuEGTriggerPass = ( ( hltbit->pass==1 && hltbit->prescale==1 ) || isMuEGTriggerPass);
            isMuEGTriggerPS0 = ( ( hltbit->prescale==0 ) || isMuEGTriggerPS0);
          }
          else isTriggerPassPrescaled = ( hltbit->pass==1 || isTriggerPassPrescaled);
        }
        if( isMuEGTriggerPass ) break;
      }
      for( int t=0; t<int(mc_hlt_MET_trigger_collection.size()); t++ ){
        //hlt_name = hltbit->name;
	    if( (hlt_name.find(mc_hlt_MET_trigger_collection[t])!=std::string::npos) ) {
	      if( hltbit->prescale==1 || hltbit->prescale==0 ) {
            METTriggerFound = true;
            isMETTriggerPass = ( ( hltbit->pass==1 && hltbit->prescale==1 ) || isMETTriggerPass);
            isMETTriggerPS0 = ( ( hltbit->prescale==0 ) || isMETTriggerPS0);
          }
          else isTriggerPassPrescaled = ( hltbit->pass==1 || isTriggerPassPrescaled);
        }
        if( isMETTriggerPass ) break;
      }
      //if( isTriggerPass ) break;
    }
    if (isDoubleMuTriggerPass || isDoubleElectronTriggerPass || isMuEGTriggerPass) isTriggerPass = true;
    if (DoubleMuTriggerFound || DoubleElectronTriggerFound || MuEGTriggerFound || METTriggerFound) triggerFound = true;


	//      }

      // Print triggers
      //triggerFound = false;
      /// make sure trigger used to tag exists in the event
    if( !triggerFound ){
      std::cout << "  error ===> Trigger not found!!!  Here are the available triggers: " << std::endl;
      for( TrigIter hltbit = hlt.begin(); hltbit != hlt.end(); ++hltbit ){
        hlt_name = hltbit->name;
        std::cout << "\t\t " << hlt_name << "\t\t prescale = " << hltbit->prescale << "\t\t pass = " << hltbit->pass << std::endl;
      }
//       break;
    }

    nevents++;
    nevents_wgt+=weight;
    

    // Event cleaning requirements
    bool passGoodVertex = ( numPV>0 ) ? true : false;
    bool passFilterOutScraping = ( event->FilterOutScraping==1 ) ? true : false;
    bool passHBHENoiseFilter = ( event->HBHENoiseFilter==1 ) ? true : false;
    
    bool isCleanEvent = ( passGoodVertex && passFilterOutScraping && passHBHENoiseFilter );
    isCleanEvent = (isData) ?  isCleanEvent : true;

    int numPartons = beanHelper.GetNumExtraPartons(mcparticles);
    if ( tmpName.Contains("wjets_0p") || tmpName.Contains("zjets_0p") ) {
      if (numPartons > 0) continue;
    }
    
    //////////split nGen
    if( (eventSampleNumber>=100 && eventSampleNumber<=300)
        || (eventSampleNumber>=7100 && eventSampleNumber<=7300)
        || (eventSampleNumber>=8100 && eventSampleNumber<=8300)
        || (eventSampleNumber>=9100 && eventSampleNumber<=9300) ) {

      bool has2tWb = false;
      bool has2tWb_Wqq_Wemu = false;
      bool has2tWb_Wqq_Wemutau = false;
      bool has2tWb_Wqq_Wemu_Hbb = false;
      bool has2tWb_Wqq_Wemutau_Hbb = false;
      bool has2tWb_2Wemu = false;
      bool has2tWb_2Wemutau = false;
      bool has2tWb_2Wemu_Hbb = false;
      bool has2tWb_2Wemutau_Hbb = false;
      
      int numWt=0, numbH=0, numqW=0, numlnuW=0, numlnutauW=0;
      for( int i=0; i<int(mcparticles.size()); i++ ){
        int id = mcparticles.at(i).id;
        int motherID = mcparticles.at(i).motherId;
        int grandMotherID = mcparticles.at(i).grandMotherId;

        if( abs(id)==24 && abs(motherID)==6 ) numWt++;
        if( abs(id)==5 && abs(motherID)==25 ) numbH++;
        if( abs(id)<=5 && abs(motherID)==24 && abs(grandMotherID)==6 ) numqW++;
        if( (abs(id)>=11 && abs(id)<=14) && abs(motherID)==24 && abs(grandMotherID)==6 ) numlnuW++;
        if( (abs(id)>=11 && abs(id)<=16) && abs(motherID)==24 && abs(grandMotherID)==6 ) numlnutauW++;
      }

      if( numWt==2 ) has2tWb = true;
      if( numqW==2 && numlnuW==2 ) has2tWb_Wqq_Wemu = true;
      if( numqW==2 && numlnutauW==2 ) has2tWb_Wqq_Wemutau = true;
      if( has2tWb_Wqq_Wemu && numbH==2 ) has2tWb_Wqq_Wemu_Hbb = true;
      if( has2tWb_Wqq_Wemutau && numbH==2 ) has2tWb_Wqq_Wemutau_Hbb = true;
      if( numlnuW==4 ) has2tWb_2Wemu = true;
      if( numlnutauW==4 ) has2tWb_2Wemutau = true;
      if( has2tWb_2Wemu && numbH==2 ) has2tWb_2Wemu_Hbb = true;
      if( has2tWb_2Wemutau && numbH==2 ) has2tWb_2Wemutau_Hbb = true;


      if( has2tWb ) h_nGen->Fill(0);
      if( has2tWb_Wqq_Wemu ) h_nGen->Fill(1);
      if( has2tWb_Wqq_Wemutau ) h_nGen->Fill(2);
      if( has2tWb_Wqq_Wemu_Hbb ) h_nGen->Fill(3);
      if( has2tWb_Wqq_Wemutau_Hbb ) h_nGen->Fill(4);
      if( has2tWb_2Wemu ) h_nGen->Fill(5);
      if( has2tWb_2Wemutau ) h_nGen->Fill(6);
      if( has2tWb_2Wemu_Hbb ) h_nGen->Fill(7);
      if( has2tWb_2Wemutau_Hbb ) h_nGen->Fill(8);
    }
      //////////

    if (verbose) std::cout << "about to do ele selection " <<std::endl;

      
    /////////
    ///
    /// Electrons
    ///
    ////////
    ////--------- using selectors in "beanHelper.h"
    ////////////////////////////////

    BNelectronCollection electronsTight;
    BNelectronCollection electronsInclusivelyLoose;
    BNelectronCollection electronsInclusivelySide;
    BNelectronCollection electronsLoose;
    BNelectronCollection electronsSide;
    BNelectronCollection electronsTL;
    BNelectronCollection electronsTS;
    BNelectronCollection electronsSelected;

    int numElectrons = dInt;
    int numTightElectrons = dInt;
    int numLooseElectrons = dInt;
    int numSideElectrons = dInt;

    if (selectionYearStr == "2011") {
      electronsTight = beanHelper.GetSelectedElectrons(looseElectrons,electronID::electronTight);
      electronsInclusivelyLoose = beanHelper.GetSelectedElectrons(looseElectrons,electronID::electronLoose);
      electronsInclusivelySide = beanHelper.GetSelectedElectrons(looseElectrons,electronID::electronSide);
    }
    else if (selectionYearStr == "2012_52x") {
      electronsTight = beanHelper.GetSelectedElectrons(electrons,electronID::electronTight);
      electronsInclusivelyLoose = beanHelper.GetSelectedElectrons(electrons,electronID::electronLoose);
    }
    else if (selectionYearStr == "2012_53x") {
      electronsTight = beanHelper.GetSelectedElectrons(electrons,electronID::electronTight);
      if (useSideLeptons) electronsInclusivelyLoose = beanHelper.GetSelectedElectrons(looseElectrons,electronID::electronLoose);
      else electronsInclusivelyLoose = beanHelper.GetSelectedElectrons(electrons,electronID::electronLoose);
      electronsInclusivelySide = beanHelper.GetSelectedElectrons(looseElectrons,electronID::electronSide);
    }
    else {
      assert (selectionYearStr == "either 2012_52x, 2012_53x, or 2011");
    }

      
    try { electronsLoose = beanHelper.GetSymmetricDifference(electronsInclusivelyLoose,electronsTight); }
    catch(...) { std::cerr << " exception in GetSymmetricDifference" << std::endl; continue; } //Don't segfault if two leptons have same eta,phi but different pt
    try { electronsTL = beanHelper.GetUnionUnsorted(beanHelper.GetSortedByPt(electronsTight),beanHelper.GetSortedByPt(electronsInclusivelyLoose)); }
    catch(...) { std::cerr << " exception in GetUnionUnsorted" << std::endl; continue; } //Don't segfault if two leptons have same eta,phi but different pt
    if (selectionYearStr == "2011" || selectionYearStr == "2012_53x") {
      try { electronsSide = beanHelper.GetSymmetricDifference(electronsInclusivelySide,electronsInclusivelyLoose); }
      catch(...) { std::cerr << " exception in GetUnionUnsorted" << std::endl; continue; } //Don't segfault if two leptons have same eta,phi but different pt
      try { electronsTS = beanHelper.GetUnionUnsorted(beanHelper.GetSortedByPt(electronsTight),beanHelper.GetSortedByPt(electronsInclusivelySide)); }
      catch(...) { std::cerr << " exception in GetUnionUnsorted" << std::endl; continue; } //Don't segfault if two leptons have same eta,phi but different pt
    }

    if (useSideLeptons) {
      electronsSelected = electronsTS;
      numElectrons = electronsTS.size();
    }
    else {
      electronsSelected = electronsTL;
      numElectrons = electronsTL.size();
    }
      
    numTightElectrons = electronsTight.size();
    numLooseElectrons = electronsTL.size() - electronsTight.size();
    numSideElectrons = electronsTS.size() - electronsTight.size();
    
    /////////
    ///
    /// Muons
    ///
    ////////
    ////--------- using selectors in "beanHelper.h"
    ////////////////////////////////

    BNmuonCollection muonsTight;
    BNmuonCollection muonsInclusivelyLoose;
    BNmuonCollection muonsInclusivelySide;
    BNmuonCollection muonsLoose;
    BNmuonCollection muonsSide;
    BNmuonCollection muonsTL;
    BNmuonCollection muonsTS;
    BNmuonCollection muonsSelected;

    int numMuons = dInt;
    int numTightMuons = dInt;
    int numLooseMuons = dInt;
    int numSideMuons = dInt;
    
    if (selectionYearStr == "2011") {
      muonsTight = beanHelper.GetSelectedMuons(looseMuons,muonID::muonTight);
      muonsInclusivelyLoose = beanHelper.GetSelectedMuons(looseMuons,muonID::muonLoose);
      muonsInclusivelySide = beanHelper.GetSelectedMuons(looseMuons,muonID::muonSide);
    }
    else if (selectionYearStr == "2012_52x") {
      muonsTight = beanHelper.GetSelectedMuons(muons,muonID::muonTight);
      muonsInclusivelyLoose = beanHelper.GetSelectedMuons(muons,muonID::muonLoose);
    }
    else if (selectionYearStr == "2012_53x") {
      muonsTight = beanHelper.GetSelectedMuons(muons,muonID::muonTight);
      muonsInclusivelyLoose = beanHelper.GetSelectedMuons(muons,muonID::muonLoose);
      muonsInclusivelySide = beanHelper.GetSelectedMuons(looseMuons,muonID::muonSide);
    }
    else {
      assert (selectionYearStr == "either 2012_52x, 2012_53x, or 2011");
    }

    try { muonsLoose = beanHelper.GetSymmetricDifference(muonsInclusivelyLoose,muonsTight); }
    catch(...) { std::cerr << " exception in GetSymmetricDifference" << std::endl; continue; } //Don't segfault if two leptons have same eta,phi but different pt
    try { muonsTL = beanHelper.GetUnionUnsorted(beanHelper.GetSortedByPt(muonsTight),beanHelper.GetSortedByPt(muonsInclusivelyLoose)); }
    catch(...) { std::cerr << " exception in GetUnionUnsorted" << std::endl; continue; } //Don't segfault if two leptons have same eta,phi but different pt
    if (selectionYearStr == "2011" || selectionYearStr == "2012_53x") {    
      try { muonsSide = beanHelper.GetSymmetricDifference(muonsInclusivelySide,muonsInclusivelyLoose); }
      catch(...) { std::cerr << " exception in GetSymmetricDifference" << std::endl; continue; } //Don't segfault if two leptons have same eta,phi but different pt
      try { muonsTS = beanHelper.GetUnionUnsorted(beanHelper.GetSortedByPt(muonsTight),beanHelper.GetSortedByPt(muonsInclusivelySide)); }
      catch(...) { std::cerr << " exception in GetUnionUnsorted" << std::endl; continue; } //Don't segfault if two leptons have same eta,phi but different pt
    }

    if (useSideLeptons) {
      muonsSelected = muonsTS;
      numMuons = muonsTS.size();
    }
    else {
      muonsSelected = muonsTL;
      numMuons = muonsTL.size();
    }
      
    numTightMuons = muonsTight.size();
    numLooseMuons = muonsTL.size() - muonsTight.size();
    numSideMuons = muonsTS.size() - muonsSide.size();


    bool PassTwoLepton = (( numTightMuons + numLooseMuons + numTightElectrons + numLooseElectrons )== 2 && ( numTightMuons + numTightElectrons )> 0 );
    if (useSideLeptons) PassTwoLepton = ( ( numMuons + numElectrons ) >= 2
                                          && ( ( numTightMuons + numTightElectrons > 0 ) || ( numLooseMuons + numLooseElectrons == 2 ) )
                                               && ( numTightMuons + numLooseMuons + numTightElectrons + numLooseElectrons ) <= 2 );
    //if ( !PassTwoLepton ) continue ;
    if ( debug_ && muons.size() + electrons.size() < 2 ) cout << "Event " << cnt << ", input collection of leptons less than 2" << endl;
    if ( debug_ && muons.size() + electrons.size() > 2 ) cout << "Event " << cnt << ", Input collection of leptons greater than 2" << endl;
    if ( !PassTwoLepton ) {
      if (debug_) cout << "Too few leptons, even on a skimmed file" << endl;
      if (debug_) cout << "Muons: " << muons.size() << ", tight: " << numTightMuons << ", loose: " << numLooseMuons << endl;
      if (debug_) cout << "Electrons: " << electrons.size() << ", tight: " << numTightElectrons << ", loose: " << numLooseElectrons << endl;
      continue;
    }

    /////////
    ///
    /// Pfjets
    ///
    ////////

    //beanHelper.GetSelectedJets(const BNjetCollection& iJets, const float iMinPt, const float iMaxAbsEta, const jetID::jetID iJetID, const char iCSVwp)
    //beanHelper.GetUncorrectedJets(const BNjetCollection& iCorrectedJets, const BNjetCollection& iOriginalJets)
    
      std::vector<int> jet_index;
      int first_CSV_index_finder = 99;
      int second_CSV_index_finder = 99;
      int first_CSV_index = -1;
      int second_CSV_index = -1;
      std::vector<int> allJet_index;
      std::vector<int> tagJet_index;
      std::vector<int> looseTagJet_index;
      std::list<float> jet_CSV_list;      
      std::vector<float> jet_CSV;
      std::vector<int> untagJet_index;
      std::vector<float> tagJet_CSV;

      std::vector<int>    allJet_motherID;
      
      vfloat jet_px;
      vfloat jet_py;
      vfloat jet_pz;
      vfloat jet_pt;
      vfloat jet_energy;
      vfloat jet_CHEF;
      vfloat jet_charge;

      int numGoodJets=0;
      int numHiggsJets=0;
      int numHiggsAllJets=0;
      int numGoodAndBadJets=0;
      int numBadJets=0;
      vLorentz jetV;
      vLorentz allJetV;
      vLorentz higgsJetV;
      vLorentz higgsGenJetV;
      vLorentz higgsGenPartonV;
      TLorentzVector jetVector;
      TLorentzVector allJetVector;
      TLorentzVector higgsJetVector;
      TLorentzVector higgsGenJetVector;
      TLorentzVector higgsGenPartonVector;

      TLorentzVector muonTemp;
      TLorentzVector electronTemp;
      TLorentzVector trackTemp;
      vLorentz higgsClosestMuonV;
      vLorentz higgsClosestElectronV;
      vLorentz higgsClosestTrackV;
      TLorentzVector higgsClosestMuonVector;
      TLorentzVector higgsClosestElectronVector;
      TLorentzVector higgsClosestTrackVector;

      float higgs_dijet_jet1_csv = dFloat;
      float higgs_dijet_jet2_csv = dFloat;
      float higgs_dijet_jet1_btagSoftMuon = dFloat;
      float higgs_dijet_jet2_btagSoftMuon = dFloat;
      float higgs_dijet_jet1_btagSoftEle = dFloat;
      float higgs_dijet_jet2_btagSoftEle = dFloat;
      float higgs_dijet_jet1_Nconst = dFloat;
      float higgs_dijet_jet2_Nconst = dFloat;
      //float higgs_dijet_jet1_mass = dFloat;
      //float higgs_dijet_jet2_mass = dFloat;
      //float higgs_dijet_jet1_area = dFloat;
      //float higgs_dijet_jet2_area = dFloat;
      //float higgs_dijet_jet1_charge = dFloat;
      //float higgs_dijet_jet2_charge = dFloat;
      float higgs_dijet_jet1_leadCandPt = dFloat;
      float higgs_dijet_jet2_leadCandPt = dFloat;
      float higgs_dijet_jet1_leadCandDistFromPV= dFloat;
      float higgs_dijet_jet2_leadCandDistFromPV = dFloat;
            
      bool jerDebugPrint = false;

      /////////////////////////////////////////////////
      //
      //   Loop over jets
      //
      // 
      /////////////////////////////////////////////////

      if (jerDebugPrint || verbose)
        cout << "\n--------------new event------------------" << endl;

      BNjetCollection const &pfjetsSelected = beanHelper.GetCorrectedJets(pfjets,iSysType);
      BNjetCollection const &pfjetsSelected_CSV_sorted = beanHelper.GetSortedByCSV( pfjetsSelected );
      BNjetCollection const &pfjetsSelected_Uncorrected = beanHelper.GetUncorrectedJets(pfjetsSelected,pfjets);

      //////////////////
      ////////// csv reweighting
      //////////////////
      double csvWgtlf[7] = {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0};
      double csvWgthf[7] = {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0};
      if ( !isData ) {
	BNjetCollection const &selectedJets_unsorted  = beanHelper.GetSelectedJets( pfjetsSelected, 30., 2.4, jetID::jetLoose, '-' ); 
	BNjetCollection const &selectedJets       = beanHelper.GetSortedByPt( selectedJets_unsorted );
	vdouble csvWgt = beanHelper.GetCSVweights( selectedJets, iSysType );
	csvWgthf[0] = csvWgt[0];
	csvWgtlf[0] = csvWgt[1];

	if ( jes == 0 ) {
	  vdouble csvWgtLFup = beanHelper.GetCSVweights( selectedJets, sysType::CSVLFup );
	  vdouble csvWgtLFdown = beanHelper.GetCSVweights( selectedJets, sysType::CSVLFdown );
	  vdouble csvWgtHFStats1up = beanHelper.GetCSVweights( selectedJets, sysType::CSVHFStats1up );
	  vdouble csvWgtHFStats1down = beanHelper.GetCSVweights( selectedJets, sysType::CSVHFStats1down );
	  vdouble csvWgtHFStats2up = beanHelper.GetCSVweights( selectedJets, sysType::CSVHFStats2up );
	  vdouble csvWgtHFStats2down = beanHelper.GetCSVweights( selectedJets, sysType::CSVHFStats2down );
	  csvWgthf[1] = csvWgtLFup[0];
	  csvWgthf[2] = csvWgtLFdown[0];
	  csvWgthf[3] = csvWgtHFStats1up[0];
	  csvWgthf[4] = csvWgtHFStats1down[0];
	  csvWgthf[5] = csvWgtHFStats2up[0];
	  csvWgthf[6] = csvWgtHFStats2down[0];

	  vdouble csvWgtHFup = beanHelper.GetCSVweights( selectedJets, sysType::CSVHFup );
	  vdouble csvWgtHFdown = beanHelper.GetCSVweights( selectedJets, sysType::CSVHFdown );
	  vdouble csvWgtLFStats1up = beanHelper.GetCSVweights( selectedJets, sysType::CSVLFStats1up );
	  vdouble csvWgtLFStats1down = beanHelper.GetCSVweights( selectedJets, sysType::CSVLFStats1down );
	  vdouble csvWgtLFStats2up = beanHelper.GetCSVweights( selectedJets, sysType::CSVLFStats2up );
	  vdouble csvWgtLFStats2down = beanHelper.GetCSVweights( selectedJets, sysType::CSVLFStats2down );
	  csvWgtlf[1] = csvWgtHFup[1];
	  csvWgtlf[2] = csvWgtHFdown[1];
	  csvWgtlf[3] = csvWgtLFStats1up[1];
	  csvWgtlf[4] = csvWgtLFStats1down[1];
	  csvWgtlf[5] = csvWgtLFStats2up[1];
	  csvWgtlf[6] = csvWgtLFStats2down[1];
	}
      }

      ///////----
      if (debug_) cout << "Looping over pfjetsSelected" << endl;

      for( int i=0; i<int(pfjetsSelected.size()); i++ ){

	float jetPt = pfjetsSelected.at(i).pt;
    float jetEta = pfjetsSelected.at(i).eta;	
    float jetAbsEta = fabs(jetEta);
    float genJetPT = pfjetsSelected.at(i).genJetPT;
    float jetPhi = pfjetsSelected.at(i).phi;
    float jetCHEF = pfjetsSelected.at(i).chargedHadronEnergyFraction;
    float jetcharge = pfjetsSelected.at(i).charge;
    //float myJER = beanHelper.getJERfactor( jer, jetAbsEta, genJetPT, jetPt);

    if (ArtificialJetPt) {
      std::random_device rd;
      std::mt19937 generator(rd());
      double mean = 1.0;
      double std  = 0.15*sqrt(50.0)/sqrt(max(pfjetsSelected.at(i).genPartonPT,20.0));
      std::normal_distribution<double> normal(mean, std);
      double jet_scale = normal(generator)*pfjetsSelected.at(i).genPartonPT/pfjetsSelected.at(i).pt;
      jetPt *= jet_scale;
      jet_px.push_back(pfjetsSelected.at(i).px*jet_scale);
      jet_py.push_back(pfjetsSelected.at(i).py*jet_scale);
      jet_pz.push_back(pfjetsSelected.at(i).pz*jet_scale);
      jet_pt.push_back(pfjetsSelected.at(i).pt*jet_scale);
      jet_energy.push_back(pfjetsSelected.at(i).energy*jet_scale);
    }
    else {
      jet_px.push_back(pfjetsSelected.at(i).px);
      jet_py.push_back(pfjetsSelected.at(i).py);
      jet_pz.push_back(pfjetsSelected.at(i).pz);
      jet_pt.push_back(pfjetsSelected.at(i).pt);
      jet_energy.push_back(pfjetsSelected.at(i).energy);
    }
    jet_CHEF.push_back(pfjetsSelected.at(i).chargedHadronEnergyFraction);
    jet_charge.push_back(pfjetsSelected.at(i).charge);    

    //Beginning of numHiggsAllJets loop
    if (debug_) cout << "Looping over numHiggsAllJets" << endl;
    if ( (tmpName.Contains("ttH") && pfjetsSelected.at(i).genPartonMotherId == 25) ||
         (sampleName == "ttbar_bb" && abs(pfjetsSelected.at(i).genPartonId) == 5 && abs(pfjetsSelected.at(i).genPartonMotherId) != 6) ||
         (sampleName == "ttbarW" && abs(pfjetsSelected.at(i).genPartonId) != 5 && abs(pfjetsSelected.at(i).genPartonMotherId) == 24) ||
         (sampleName == "ttbarZ" && abs(pfjetsSelected.at(i).genPartonId) != 5 && abs(pfjetsSelected.at(i).genPartonMotherId) == 23) ) {
      higgsJetVector.SetPxPyPzE(jet_px[i],jet_py[i],jet_pz[i],jet_energy[i]);
      higgsGenJetVector.SetPxPyPzE(pfjetsSelected.at(i).genJetPT,pfjetsSelected.at(i).genJetEta,pfjetsSelected.at(i).genJetPhi,pfjetsSelected.at(i).genJetET/sin(2*atan(exp(-pfjetsSelected.at(i).genJetEta))));
      higgsGenPartonVector.SetPxPyPzE(pfjetsSelected.at(i).genPartonPT,pfjetsSelected.at(i).genPartonEta,pfjetsSelected.at(i).genPartonPhi,pfjetsSelected.at(i).genPartonET/sin(2*atan(exp(-pfjetsSelected.at(i).genPartonEta))));
      higgsJetV.push_back(higgsJetVector);
      higgsGenJetV.push_back(higgsGenJetVector);
      higgsGenPartonV.push_back(higgsGenPartonVector);
      higgsClosestMuonVector.SetPxPyPzE(-jet_px[i],-jet_py[i],-jet_pz[i],jet_energy[i]);
      higgsClosestElectronVector.SetPxPyPzE(-jet_px[i],-jet_py[i],-jet_pz[i],jet_energy[i]);
      higgsClosestTrackVector.SetPxPyPzE(-jet_px[i],-jet_py[i],-jet_pz[i],jet_energy[i]);
      for (unsigned int ii = 0; ii < muonsSide.size(); ii++) {
        muonTemp.SetPxPyPzE(muonsSide.at(ii).px,muonsSide.at(ii).py,muonsSide.at(ii).pz,muonsSide.at(ii).energy);
        if ( higgsJetV[numHiggsAllJets].DeltaR(muonTemp) < higgsJetV[numHiggsAllJets].DeltaR(higgsClosestMuonVector) ) {
          higgsClosestMuonVector.SetPxPyPzE(muonsSide.at(ii).px,muonsSide.at(ii).py,muonsSide.at(ii).pz,muonsSide.at(ii).energy);
        }
      }
      higgsClosestMuonV.push_back(higgsClosestMuonVector);
      for (unsigned int ii = 0; ii < electronsSide.size(); ii++) {
        electronTemp.SetPxPyPzE(electronsSide.at(ii).px,electronsSide.at(ii).py,electronsSide.at(ii).pz,electronsSide.at(ii).energy);
        if ( higgsJetV[numHiggsAllJets].DeltaR(electronTemp) < higgsJetV[numHiggsAllJets].DeltaR(higgsClosestElectronVector) ) {
          higgsClosestElectronVector.SetPxPyPzE(electronsSide.at(ii).px,electronsSide.at(ii).py,electronsSide.at(ii).pz,electronsSide.at(ii).energy);
        }
      }
      higgsClosestElectronV.push_back(higgsClosestElectronVector);
      for (unsigned int ii = 0; ii < tracks.size(); ii++) {
        trackTemp.SetPxPyPzE(tracks.at(ii).px,tracks.at(ii).py,tracks.at(ii).pz,sqrt ( pow(tracks.at(ii).px,2) + pow(tracks.at(ii).py,2) + pow(tracks.at(ii).pz,2) ));
        if ( higgsJetV[numHiggsAllJets].DeltaR(trackTemp) < 0.7 ) {
          if (higgsJetV[numHiggsAllJets].DeltaR(higgsClosestTrackVector) > 0.7 || trackTemp.Pt() > higgsJetV[numHiggsAllJets].Pt() ) {
            higgsClosestTrackVector.SetPxPyPzE(tracks.at(ii).px,tracks.at(ii).py,tracks.at(ii).pz,sqrt ( pow(tracks.at(ii).px,2) + pow(tracks.at(ii).py,2) + pow(tracks.at(ii).pz,2) ));
          }
        }
      }
      higgsClosestTrackV.push_back(higgsClosestTrackVector);
      if (numHiggsAllJets==0) {
        higgs_dijet_jet1_csv  = pfjetsSelected.at(i).btagCombinedSecVertex;
        higgs_dijet_jet1_btagSoftMuon  = pfjetsSelected.at(i).btagSoftMuon;
        higgs_dijet_jet1_btagSoftEle  = pfjetsSelected.at(i).btagSoftEle;
        higgs_dijet_jet1_Nconst  = pfjetsSelected.at(i).Nconst;
        //higgs_dijet_jet1_mass  = pfjetsSelected.at(i).mass;
        //higgs_dijet_jet1_area  = pfjetsSelected.at(i).area;
        //higgs_dijet_jet1_charge  = pfjetsSelected.at(i).charge;
        higgs_dijet_jet1_leadCandPt  = pfjetsSelected.at(i).leadCandPt;
        higgs_dijet_jet1_leadCandDistFromPV = pfjetsSelected.at(i).leadCandDistFromPV;
      }
      else if (numHiggsAllJets==1) {
        higgs_dijet_jet2_csv  = pfjetsSelected.at(i).btagCombinedSecVertex;
        higgs_dijet_jet2_btagSoftMuon  = pfjetsSelected.at(i).btagSoftMuon;
        higgs_dijet_jet2_btagSoftEle  = pfjetsSelected.at(i).btagSoftEle;
        higgs_dijet_jet2_Nconst  = pfjetsSelected.at(i).Nconst;
        //higgs_dijet_jet2_mass  = pfjetsSelected.at(i).mass;
        //higgs_dijet_jet2_area  = pfjetsSelected.at(i).area;
        //higgs_dijet_jet2_charge  = pfjetsSelected.at(i).charge;
        higgs_dijet_jet2_leadCandPt  = pfjetsSelected.at(i).leadCandPt;
        higgs_dijet_jet2_leadCandDistFromPV = pfjetsSelected.at(i).leadCandDistFromPV;
      }        

      numHiggsAllJets++;
    } //End loop that sets numHiggsAllJets

    allJet_motherID.push_back(pfjetsSelected.at(i).genPartonMotherId);
    allJetVector.SetPxPyPzE(jet_px[i],jet_py[i],jet_pz[i],jet_energy[i]);
    allJetV.push_back(allJetVector);
    numGoodAndBadJets++;
    
	bool kin = ( jetPt>30. );
	bool eta = ( jetAbsEta<2.4 );
	bool id  = ( pfjetsSelected.at(i).jetIDLoose==1 );

    if (debug_) cout << "Before jet cut" << endl;

	if( !(kin && eta && id) ) {
      numBadJets++;
      continue;
    }

    if (debug_) cout << "Passed jet cut" << endl;

	if (tmpName.Contains("ttH") && pfjetsSelected.at(i).genPartonMotherId == 25) {
	  numHiggsJets++;
	} 
	else if (sampleName == "ttbar_bb" && abs(pfjetsSelected.at(i).genPartonId) == 5 && abs(pfjetsSelected.at(i).genPartonMotherId) != 6) {
	  numHiggsJets++;
	}
    else if (sampleName == "ttbarW" && abs(pfjetsSelected.at(i).genPartonMotherId) == 24) {
      numHiggsJets++;
    }
    else if (sampleName == "ttbarZ" && abs(pfjetsSelected.at(i).genPartonMotherId) == 23) {
      numHiggsJets++;
    }
    

    jetVector.SetPxPyPzE(jet_px[i],jet_py[i],jet_pz[i],jet_energy[i]);
	jetV.push_back(jetVector);
	numGoodJets++;
	jet_index.push_back(i);

    for( int j=0; j<int(pfjetsSelected_CSV_sorted.size()); j++ ) {
      if (pfjetsSelected_CSV_sorted.at(j).px == pfjetsSelected.at(i).px
          && pfjetsSelected_CSV_sorted.at(j).py == pfjetsSelected.at(i).py) {
        if (j < first_CSV_index_finder) {
          second_CSV_index_finder = first_CSV_index_finder;
          second_CSV_index = first_CSV_index;
          first_CSV_index_finder = j;
          first_CSV_index = i;
        }
        else if (j < second_CSV_index_finder) {
          second_CSV_index_finder = j;
          second_CSV_index = i;
        }
      }
    }
    
	// Use Combined tags
	// Loose Cut is 0.244
	// Medium Cut is 0.679
	// Tight Cut is 0.898


    //int iJetFlav = pfjetsSelected.at(i).flavour;
    
    float csv = pfjetsSelected.at(i).btagCombinedSecVertex;
	bool csvM = ( csv > btagThres );
	bool csvL = ( csv > btagThresLoose );

	
	if( csvM ) {
	  tagJet_index.push_back(i);
      tagJet_CSV.push_back(csv);
	}
	else { untagJet_index.push_back(i); }

	if( csvL ) looseTagJet_index.push_back(i);
	
	int flavor =  pfjetsSelected.at(i).flavour;
    
	jet_CSV.push_back(csv);
	jet_CSV_list.push_back(csv);
    
      }// end for each pf jet

    if (debug_) cout << "Finished loop over pfjets" << endl;
      
      //------------------------
      int numAllJets = numGoodAndBadJets;
      int numJets = int(jet_index.size());
      // Only select events with at least two jets
      // AWB Feb 14 2013
      // Moved this cut to the middle to avoid wasting time on calculations
      if (applySelectionJets){
        if (numJets < 2) continue;
      }

      int numTaggedJets = int(tagJet_index.size());
      int numLooseTaggedJets = int(looseTagJet_index.size());

      ///////

      bool TightMuonLooseMuon = ((numTightMuons == 1) && (numLooseMuons==1));
      bool TightMuonLooseEle = ((numTightMuons == 1) && (numLooseElectrons==1));
      bool TightEleLooseMuon = ((numTightElectrons == 1) && (numLooseMuons==1));
      bool TightEleLooseEle = ((numTightElectrons == 1) && (numLooseElectrons==1));

      bool TightMuonSideMuon = ((numTightMuons == 1) && (numSideMuons>=1));
      bool TightMuonSideEle = ((numTightMuons == 1) && (numSideElectrons>=1));
      bool TightEleSideMuon = ((numTightElectrons == 1) && (numSideMuons>=1));
      bool TightEleSideEle = ((numTightElectrons == 1) && (numSideElectrons>=1));
      
      bool twoTightMuon = (numTightMuons == 2);
      bool oneEleOneMuonTight = ((numTightMuons ==1) && (numTightElectrons ==1));
      bool twoTightEle = (numTightElectrons ==2);

      bool twoLooseMuon = (numLooseMuons == 2);
      bool oneEleOneMuonLoose = ((numLooseMuons ==1) && (numLooseElectrons ==1));
      bool twoLooseEle = (numLooseElectrons ==2);

      bool GEtwoMuon = (numMuons >= 2);
      bool GEoneEleOneMuon = ((numMuons >=1) && (numElectrons >=1));
      bool GEtwoEle = (numElectrons >=2);
      
      bool TwoMuon = PassTwoLepton && ( twoTightMuon || TightMuonLooseMuon ) ;
      bool TwoEle = PassTwoLepton && ( twoTightEle || TightEleLooseEle ) ;
      bool MuonEle = PassTwoLepton && ( TightMuonLooseEle || TightEleLooseMuon || oneEleOneMuonTight );


      if (useSideLeptons) {
        TwoMuon = PassTwoLepton && ( twoTightMuon || (TightMuonLooseMuon && TightMuonSideMuon)
                                        || ( (twoLooseMuon && GEtwoMuon)  && !(TightEleLooseEle && TightEleSideEle)
                                             && !(TightMuonLooseEle && TightMuonSideEle) && !(TightEleLooseMuon && TightEleSideMuon) )
                                        || ( TightMuonSideMuon  && !(TightEleLooseEle && TightEleSideEle)
                                             && !(TightMuonLooseEle && TightMuonSideEle) && !(TightEleLooseMuon && TightEleSideMuon)
                                             && !(oneEleOneMuonLoose && GEoneEleOneMuon) && !(twoLooseEle && GEtwoEle) ) );
        MuonEle = PassTwoLepton && !TwoMuon && ( oneEleOneMuonTight || (TightMuonLooseEle && TightMuonSideEle) || (TightEleLooseMuon && TightEleSideMuon)
                                                    || ( (oneEleOneMuonLoose && GEoneEleOneMuon) && !(TightEleLooseEle && TightEleSideEle) )
                                                    || ( (TightMuonSideEle || TightEleSideMuon) && !(TightEleLooseEle && TightEleSideEle)
                                                         && !(twoLooseEle && GEtwoEle) ) );
        TwoEle = PassTwoLepton && !TwoMuon && !MuonEle && ( twoTightEle || (twoLooseEle && GEtwoEle) || (TightEleSideEle) );
      }

      if ( !(TwoMuon || MuonEle || TwoEle) ) continue;
                                        
      
      
      //long tempLongEventNum = event->evt;
      //unsigned tempUEventNum = (unsigned) tempLongEventNum;
      //std::cout << "Check event num: long " << tempLongEventNum << " uint " << tempUEventNum << std::endl;
      

      /////////////////////////////////
      ///////
      /////// final selection for neural net training:
      //////
      ////////////////////////////////

      //met

    float metx = pfmet->px;
    float mety = pfmet->py;
    float metpt = pfmet->pt;
    float metx_new = pfmetSelected.px;
    float mety_new = pfmetSelected.py;
    float metpt_new = pfmetSelected.pt;
    
    if (jerDebugPrint || verbose)
      cout << "---> MET " << endl
           << "     metx " << metx << endl
           << "     mety " << mety << endl
           << "     metpt " << metpt <<endl
           << "     metx_new " << metx_new  << endl
           << "     mety_new " << mety_new  << endl
           << "     metpt "    << metpt_new << endl;


    
      TLorentzVector metV(metx_new,mety_new,0.0,metpt_new);
      float met = metpt_new;
      float unc_met = pfmet->Upt;


      //sort btag discriminator
      jet_CSV_list.sort();  
      std::vector<float> jet_CSV_sorted;			
      std::list<float>::iterator listint;			
      for (listint = jet_CSV_list.begin(); listint != jet_CSV_list.end(); listint++){
	jet_CSV_sorted.push_back(*listint);  //accessible form
      }

      //////  ttbb bkg -- dibjet mass combinations
      std::list<float> dibjet_mass_combinations;
      float m2H_btag = dFloat ;

      std::list<float> untagged_dijet_mass_combinations;

      std::list<float> dijet_mass_combinations;
      float dijet_mass_m2H = dFloat ;

      //sum of all jets
      TLorentzVector sum_jet_vect;
      TLorentzVector sum_allJet_vect;
      
      for (int sumv=0; sumv < numJets; sumv++) {
        sum_jet_vect += jetV[sumv];
      }
      for (int sumv=0; sumv < numAllJets; sumv++) {
        sum_allJet_vect += allJetV[sumv];
      }


      
      TLorentzVector sum_higgs_dijet_vect;
      TLorentzVector sum_higgsLike_dijet_vect;
      TLorentzVector sum_higgsLike_allDijet_vect;
      TLorentzVector sum_topLike_trijet_vect;
      TLorentzVector sum_topLike_allTrijet_vect;
      TLorentzVector sum_higgs_genJet_vect;
      TLorentzVector sum_higgs_genParton_vect;
      
      float higgs_dijet_mass = dFloat;
      float higgs_dijet_pt = dFloat;
      float higgs_dijet_pz = dFloat;
      float higgs_dijet_dR = dFloat;
      float higgs_dijet_dPhi = dFloat;
      float higgs_dijet_jet1_pt= dFloat;
      float higgs_dijet_jet2_pt = dFloat;
      float higgs_dijet_jet1_eta = dFloat;
      float higgs_dijet_jet2_eta = dFloat;
      float higgs_dijet_jet1_muon_dR= dFloat;
      float higgs_dijet_jet2_muon_dR = dFloat;
      //float higgs_dijet_jet1_muon_pt= dFloat;
      //float higgs_dijet_jet2_muon_pt = dFloat;
      float higgs_dijet_jet1_electron_dR= dFloat;
      float higgs_dijet_jet2_electron_dR = dFloat;
      //float higgs_dijet_jet1_electron_pt= dFloat;
      //float higgs_dijet_jet2_electron_pt = dFloat;
      float higgs_dijet_jet1_track_dR= dFloat;
      float higgs_dijet_jet2_track_dR = dFloat;
      float higgs_dijet_jet1_track_pt= dFloat;
      float higgs_dijet_jet2_track_pt = dFloat;
      float higgsLike_dijet_mass1 = dFloat;
      float higgsLike_dijet_mass2 = dFloat;
      float higgsLike_dijet_massX = dFloat;
      float higgsLike_dijet_ptX = dFloat;
      float higgsLike_dijet_etaX = dFloat;
      float higgsLike_diBjet_mass1 = dFloat;
      float higgsLike_dijet_dR = dFloat;
      float higgsLike_dijet_pt = dFloat;
      float higgsLike_dijet_eta = dFloat;
      float higgsLike_dijet_jet1_pt = dFloat;
      float higgsLike_dijet_jet2_pt = dFloat;
      int numHiggsLike_dijet_10 = 0;
      int numHiggsLike_dijet_15 = 0;
      int numHiggsLike_dijet_20 = 0;
      int numHiggsLike_dijet_25 = 0;
      int numHiggsLike_diBjet_10 = 0;
      int numHiggsLike_diBjet_15 = 0;
      int numHiggsLike_diBjet_20 = 0;
      int numHiggsLike_diBjet_25 = 0;
      float higgs_dijet_genJet1_pt= dFloat;
      float higgs_dijet_genJet2_pt = dFloat;
      float higgs_dijet_genParton1_pt= dFloat;
      float higgs_dijet_genParton2_pt = dFloat;
      float wLike_dijet_mass_low1CSV1 = dFloat;
      float wLike_dijet_mass_low2CSV1 = dFloat;
      float wLike_dijet_pt_low1CSV = dFloat;
      float wLike_dijet_pt_low2CSV = dFloat;
      float wLike_dijet_eta_low1CSV = dFloat;
      float wLike_dijet_eta_low2CSV = dFloat;
      float topLike_dijet_lep1_mass_low1CSV = dFloat;
      float topLike_dijet_lep1_mass_low2CSV = dFloat;
      float topLike_dijet_lep2_mass_low1CSV = dFloat;
      float topLike_dijet_lep2_mass_low2CSV = dFloat;
      float MT_MHT_lep1_b1 = dFloat;
      float MT_MHT_lep2_b1 = dFloat;
      float MT_MHT_lep1_b2 = dFloat;
      float MT_MHT_lep2_b2 = dFloat;
      float MT_met_lep1_b1 = dFloat;
      float MT_met_lep2_b1 = dFloat;
      float MT_met_lep1_b2 = dFloat;
      float MT_met_lep2_b2 = dFloat;
      float mass_lep1_b1 = dFloat;
      float mass_lep2_b1 = dFloat;
      float mass_lep1_b2 = dFloat;
      float mass_lep2_b2 = dFloat;
      float dR_lep1_b1 = dFloat;
      float dR_lep2_b1 = dFloat;
      float dR_lep1_b2 = dFloat;
      float dR_lep2_b2 = dFloat;
      float topLike_trijet_mass_hiCSV_low1CSV1 = dFloat;
      float topLike_trijet_mass_hiCSV_low1CSV2 = dFloat;
      float topLike_trijet_mass_hiCSV_low2CSV1 = dFloat;
      float topLike_trijet_mass_hiCSV_low2CSV2 = dFloat;
      float topLike_trijet_mass_medTag_low1CSV1 = dFloat;
      float topLike_trijet_mass_medTag_low1CSV2 = dFloat;
      float topLike_trijet_mass_medTag_low2CSV1 = dFloat;
      float topLike_trijet_mass_medTag_low2CSV2 = dFloat;
      float topLike_trijet_mass_looseTag_low1CSV1 = dFloat;
      float topLike_trijet_mass_looseTag_low1CSV2 = dFloat;
      float topLike_trijet_mass_looseTag_low2CSV1 = dFloat;
      float topLike_trijet_mass_looseTag_low2CSV2 = dFloat;
      float higgsLike_allDijet_mass1 = dFloat;
      float higgsLike_allDijet_mass2 = dFloat;
      float wLike_allDijet_mass1 = dFloat;
      float topLike_allTrijet_mass1 = dFloat;
      float topLike_allTrijet_mass2 = dFloat;
      float higgs_genJet_mass = dFloat;
      float higgs_genParton_mass = dFloat;
      
      if (numHiggsAllJets == 2) {
        sum_higgs_dijet_vect = higgsJetV[0] + higgsJetV[1];
        higgs_dijet_mass = sum_higgs_dijet_vect.M();
        higgs_dijet_pt = sum_higgs_dijet_vect.Pt();
        higgs_dijet_pz = sum_higgs_dijet_vect.Pz();
        higgs_dijet_dR = higgsJetV[0].DeltaR(higgsJetV[1]);
        higgs_dijet_dPhi = higgsJetV[0].DeltaPhi(higgsJetV[1]);
        higgs_dijet_jet1_pt = higgsJetV[0].Pt();
        higgs_dijet_jet2_pt = higgsJetV[1].Pt();
        higgs_dijet_jet1_eta = higgsJetV[0].Eta();
        higgs_dijet_jet2_eta = higgsJetV[1].Eta();
        higgs_dijet_genJet1_pt = higgsGenJetV[0].Pt();
        higgs_dijet_genJet2_pt = higgsGenJetV[1].Pt();
        higgs_dijet_genParton1_pt = higgsGenPartonV[0].Pt();
        higgs_dijet_genParton2_pt = higgsGenPartonV[1].Pt();
        higgs_dijet_jet1_muon_dR = higgsJetV[0].DeltaR(higgsClosestMuonV[0]);
        higgs_dijet_jet2_muon_dR = higgsJetV[1].DeltaR(higgsClosestMuonV[1]);
        //higgs_dijet_jet1_muon_pt = higgsClosestMuonV[0].Pt();
        //higgs_dijet_jet2_muon_pt = higgsClosestMuonV[1].Pt();
        higgs_dijet_jet1_electron_dR = higgsJetV[0].DeltaR(higgsClosestElectronV[0]);
        higgs_dijet_jet2_electron_dR = higgsJetV[1].DeltaR(higgsClosestElectronV[1]);
        //higgs_dijet_jet1_electron_pt = higgsClosestElectronV[0].Pt();
        //higgs_dijet_jet2_electron_pt = higgsClosestElectronV[1].Pt();
        higgs_dijet_jet1_track_dR = higgsJetV[0].DeltaR(higgsClosestTrackV[0]);
        higgs_dijet_jet2_track_dR = higgsJetV[1].DeltaR(higgsClosestTrackV[1]);
        higgs_dijet_jet1_track_pt = higgsClosestTrackV[0].Pt();
        higgs_dijet_jet2_track_pt = higgsClosestTrackV[1].Pt();
        sum_higgs_genJet_vect = higgsGenJetV[0] + higgsGenJetV[1];
        higgs_genJet_mass = sum_higgs_genJet_vect.M();
        sum_higgs_genParton_vect = higgsGenPartonV[0] + higgsGenPartonV[1];
        higgs_genParton_mass = sum_higgs_genParton_vect.M();
      }
      if (numHiggsAllJets > 2) {
        std::cout << "First three higgs jets have pt " << higgsJetV[0].Pt() << ", " << higgsJetV[1].Pt() << ", " << higgsJetV[2].Pt() << std::endl;
      }

      TLorentzVector dijet_vect;
      TLorentzVector lep_vect1;
      TLorentzVector lep_vect2;
      TLorentzVector lep_vect1_transverse;
      TLorentzVector lep_vect2_transverse;
      TLorentzVector jet_vect;
      TLorentzVector jet_vect_transverse;
      TLorentzVector allJet_vect;
      
      TLorentzVector btag_vect1;
      TLorentzVector btag_vect2;

      // ttbb
      TLorentzVector jet_vect1;
      TLorentzVector jet_vect2;
      
      float first_bjet_pt = dFloat ;
      float first_jet_pt = dFloat ;
      float second_jet_pt = dFloat ;
      float third_jet_pt = dFloat ;
      float fourth_jet_pt = dFloat ;
      
      float first_jet_eta = dFloat;
      float second_jet_eta = dFloat;
      float third_jet_eta = dFloat;
      float fourth_jet_eta = dFloat;

      float first_jet_CHEF = dFloat;
      float second_jet_CHEF = dFloat;
      float third_jet_CHEF = dFloat;
      float fourth_jet_CHEF = dFloat;
      float sum_jet_CHEF = dFloat;
      
      float first_jet_CSV = dFloat ;
      float second_jet_CSV = dFloat ;
      float third_jet_CSV = dFloat ;
      float fourth_jet_CSV = dFloat ;

      float first_jet_CSV_unc = dFloat ;
      float second_jet_CSV_unc = dFloat ;
      float third_jet_CSV_unc = dFloat ;
      float fourth_jet_CSV_unc = dFloat ;

      float first_jet_charge = dFloat;
      float second_jet_charge = dFloat;
      float third_jet_charge = dFloat;
      float fourth_jet_charge = dFloat;
      float sum_jet_charge = dFloat;
      float sum_untagged_jet_charge = dFloat;
      float sum_tagged_jet_charge = dFloat;
      
      int first_jet_genID = dInt ;
      int second_jet_genID = dInt ;
      int third_jet_genID = dInt ;
      int fourth_jet_genID = dInt ;
      int first_jet_flavor = dInt ;
      int second_jet_flavor = dInt ;
      int third_jet_flavor = dInt ;
      int fourth_jet_flavor = dInt ;

      float b1_jet_pt = dFloat;
      float b2_jet_pt = dFloat;
      float b1_jet_eta = dFloat;
      float b2_jet_eta = dFloat;
      float b1_jet_CSV = dFloat;
      float b2_jet_CSV = dFloat;

      float first_lf_jet_pt = dFloat;
      float first_lf_jet_eta = dFloat;
      float first_lf_jet_CSV_unshaped = dFloat;
      float first_lf_jet_CSV_reshaped = dFloat;

      float first_hf_jet_pt = dFloat;
      float first_hf_jet_eta = dFloat;
      float first_hf_jet_CSV_unshaped = dFloat;
      float first_hf_jet_CSV_reshaped = dFloat;

      float CSV_30to45_0p0to1p2_1 = dFloat ;
      float CSV_45to75_0p0to1p2_1 = dFloat ;
      float CSV_75to150_0p0to1p2_1 = dFloat ;
      float CSV_150toInf_0p0to1p2_1 = dFloat ;
      float CSV_30to45_1p2to2p1_1 = dFloat ;
      float CSV_45to75_1p2to2p1_1 = dFloat ;
      float CSV_75to150_1p2to2p1_1 = dFloat ;
      float CSV_150toInf_1p2to2p1_1 = dFloat ;
      float CSV_30to45_2p1to2p4_1 = dFloat ;
      float CSV_45to75_2p1to2p4_1 = dFloat ;
      float CSV_75to150_2p1to2p4_1 = dFloat ;
      float CSV_150toInf_2p1to2p4_1 = dFloat ;

      float CSV_30to45_0p0to1p2_2 = dFloat ;
      float CSV_45to75_0p0to1p2_2 = dFloat ;
      float CSV_75to150_0p0to1p2_2 = dFloat ;
      float CSV_150toInf_0p0to1p2_2 = dFloat ;
      float CSV_30to45_1p2to2p1_2 = dFloat ;
      float CSV_45to75_1p2to2p1_2 = dFloat ;
      float CSV_75to150_1p2to2p1_2 = dFloat ;
      float CSV_150toInf_1p2to2p1_2 = dFloat ;
      float CSV_30to45_2p1to2p4_2 = dFloat ;
      float CSV_45to75_2p1to2p4_2 = dFloat ;
      float CSV_75to150_2p1to2p4_2 = dFloat ;
      float CSV_150toInf_2p1to2p4_2 = dFloat ;

      float first_allJet_pt = dFloat ;
      float second_allJet_pt = dFloat ;
      float third_allJet_pt = dFloat ;
      float fourth_allJet_pt = dFloat ;
      
      float mindr_lep1_jet = dFloat;
      float mindr_lep2_jet = dFloat;
      float mindr_lep1_allJet = dFloat;
      float mindr_lep2_allJet = dFloat;
      float min_dr_tagged_jets = dFloat;
      float min_dr_jets = dFloat;
      float ptRel_lep1_jet = dFloat;
      float ptRel_lep2_jet = dFloat;
      float ptRel_lep1_allJet = dFloat;
      float ptRel_lep2_allJet = dFloat;
      
      float denom_avg_cnt = dFloat;
      float avg_btag_disc_btags = dFloat;     
      float avg_btag_disc_non_btags = dFloat;
      float highest_btag_disc_non_btags = dFloat;
      float dev_from_avg_disc_btags = dFloat;
      float first_highest_btag = dFloat;
      float second_highest_btag = dFloat;
      float lowest_btag = dFloat;

      float sum_pt = dFloat;
      float sum_jet_pt = dFloat;
      float all_sum_pt = dFloat;
      float Ht = dFloat;

      //ttbb
      float dijet_mass_first  = dFloat;
      float dijet_mass_second = dFloat;
      float dijet_mass_third  = dFloat;
      float dijet_mass_lowest  = dFloat;

      float first_dibjet_mass  = dFloat;
      float second_dibjet_mass = dFloat;
      float third_dibjet_mass  = dFloat;
      float lowest_dibjet_mass  = dFloat;

      float first_untagged_dijet_mass  = dFloat;
      float second_untagged_dijet_mass = dFloat;
      float third_untagged_dijet_mass  = dFloat;
      float lowest_untagged_dijet_mass  = dFloat;

      float avg_dr_jets = dFloat;
      float avg_dijet_mass = dFloat;
      float closest_dijet_mass = dFloat;
      float M2_of_closest_jets = dFloat;
     
      float avg_dr_tagged_jets = dFloat;
      float avg_tagged_dijet_mass = dFloat;
      float closest_tagged_dijet_mass = dFloat;
      float M2_of_closest_tagged_jets = dFloat;
      float min_dr_genB1_allJet = dFloat;
      float min_dr_genB2_allJet = dFloat;
      
      TLorentzVector non_btag_vect1;
      TLorentzVector non_btag_vect2;
      float avg_untagged_dijet_mass = dFloat;

      if ( PassTwoLepton ){  //////// number of jets and number of tags
	
	float lep1Pt = dFloat;
	float lep2Pt = dFloat;
	float lep1_et = dFloat;
	float lep2_et = dFloat;
	float lep1Eta = dFloat;
	float lep2Eta = dFloat;
	float lep1Phi = dFloat;
	float lep2Phi = dFloat;
    float lep1_tkDZ = dFloat;
    float lep2_tkDZ = dFloat;
    float lep1Iso = dFloat;
    float lep2Iso = dFloat;
    float lep1ChargedIso = dFloat;
    float lep2ChargedIso = dFloat;
    float lep1NeutralIso = dFloat;
    float lep2NeutralIso = dFloat;
    float lep1IP = dFloat;
    float lep2IP = dFloat;
    float lep1IPError = dFloat;
    float lep2IPError = dFloat;
    float lep1dFracScEtTkPt = dFloat;
    float lep2dFracScEtTkPt = dFloat;
    float lep1_correctedDZ = dFloat;
    float lep2_correctedDZ = dFloat;
    float lep1_correctedD0 = dFloat;
    float lep2_correctedD0 = dFloat;
    float lep1TkCharge = dFloat;
    float lep2TkCharge = dFloat;
    float lep1GenCharge = dFloat;
    float lep2GenCharge = dFloat;
    float lep1GsfCharge = dFloat;
    float lep2GsfCharge = dFloat;
    int lep1GenID = dInt;
    int lep2GenID = dInt;
    int lep1GenMotherID = dInt;
    int lep2GenMotherID = dInt;
    int lep1IsPrompt = dInt;
    int lep2IsPrompt = dInt;
    int lep1Flavor = dInt;
    int lep2Flavor = dInt;
    float lep1SF = dFloat;
    float lep2SF = dFloat;

    float triggerSF = dFloat;
    //float newSingleMuSF = dFloat;
    //float newSingleEleSF = dFloat;
    //float oldSingleMuSF = dFloat;
    //float oldSingleEleSF = dFloat;

    float lep1FlipSF = dFloat;
    float lep2FlipSF = dFloat;
    float lep1FlipSFUp = dFloat;
    float lep2FlipSFUp = dFloat;
    float lep1FlipSFDown = dFloat;
    float lep2FlipSFDown = dFloat;
    float lep1PromptSF = dFloat;
    float lep2PromptSF = dFloat;
    float lep1PromptSFUp = dFloat;
    float lep2PromptSFUp = dFloat;
    float lep1PromptSFDown = dFloat;
    float lep2PromptSFDown = dFloat;
    int lep1PassSSCut = dInt;
    int lep2PassSSCut = dInt;
    int lep2IsGlobalMuon = dInt;
    int lep2IsTrackerMuon = dInt;
    int lep2IsGlobalMuonPromptTight = dInt;
    int lep2NumTrackHits = dInt;
    int lep2NumPixelHits = dInt;
    int lep2NumberOfMatches = dInt;
    float lep2Chi2 = dFloat;
    int lep2NumExpectedHits = dInt;
    
    BNmcparticle MCLep1;
    BNmcparticle MCLep2;
    
	  if( twoTightMuon || TightMuonLooseMuon ) {

        muonID::muonID firstLep = muonID::muonTight;
        muonID::muonID secondLep = (TightMuonLooseMuon) ? muonID::muonLoose : muonID::muonTight;
        lep1SF = beanHelper.GetMuonSF(muonsSelected.at(0), firstLep);
        lep2SF = beanHelper.GetMuonSF(muonsSelected.at(1), secondLep);

        if (debug_) cout << "DEBUG: Calling double muon trigger SF...";
        triggerSF = beanHelper.GetDoubleMuonTriggerSF(muonsSelected.at(0), muonsSelected.at(1));
        if (debug_) cout << "Returned!" << endl;

        //newSingleMuSF = beanHelper.TestSingleMuonTriggerNew(muonsSelected.at(0));
        //oldSingleMuSF = beanHelper.TestSingleMuonTriggerOld(muonsSelected.at(0));


	    lep1Pt = muonsSelected.at(0).pt;
	    lep2Pt = muonsSelected.at(1).pt;
	    
	    lep1_et = muonsSelected.at(0).et;
	    lep2_et = muonsSelected.at(1).et;  

	    lep1Eta = muonsSelected.at(0).eta;
	    lep2Eta = muonsSelected.at(1).eta;  

	    lep1Phi = muonsSelected.at(0).phi;
	    lep2Phi = muonsSelected.at(1).phi;  

        lep1_tkDZ = muonsSelected.at(0).tkDZ;
        lep2_tkDZ = muonsSelected.at(1).tkDZ;

        lep1_correctedDZ = muonsSelected.at(0).correctedDZ;
        lep2_correctedDZ = muonsSelected.at(1).correctedDZ;

        lep1_correctedD0 = muonsSelected.at(0).correctedD0;
        lep2_correctedD0 = muonsSelected.at(1).correctedD0;
        
        lep1IP = muonsSelected.at(0).IP;
        lep2IP = muonsSelected.at(1).IP;
        
        lep1IPError = muonsSelected.at(0).IPError;
        lep2IPError = muonsSelected.at(1).IPError;
        
        lep1TkCharge = muonsSelected.at(0).tkCharge;
        lep2TkCharge = muonsSelected.at(1).tkCharge;

        lep1GenID = muonsSelected.at(0).genId;
        lep2GenID = muonsSelected.at(1).genId;

        lep1GenMotherID = muonsSelected.at(0).genMotherId;
        lep2GenMotherID = muonsSelected.at(1).genMotherId;

        lep1GenCharge = muonsSelected.at(0).genCharge;
        lep2GenCharge = muonsSelected.at(1).genCharge;

        if (lep1GenID == -99) {
          MCLep1 = beanHelper.GetMatchedMCparticle(mcparticles,muonsSelected.at(0),0.1);
          if (MCLep1.id != -99 && abs(MCLep1.id) != 6 && abs(MCLep1.id) != 23 && abs(MCLep1.id) != 24 && abs(MCLep1.id) != 25) {
            lep1GenID = MCLep1.id;
            lep1GenMotherID = MCLep1.motherId;
            lep1GenCharge = MCLep1.charge;
          }
        }
        if (lep2GenID == -99) {
          MCLep2 = beanHelper.GetMatchedMCparticle(mcparticles,muonsSelected.at(1),0.1);
          if (MCLep2.id != -99 && abs(MCLep2.id) != 6 && abs(MCLep2.id) != 23 && abs(MCLep2.id) != 24 && abs(MCLep2.id) != 25) {
            lep2GenID = MCLep2.id;
            lep2GenMotherID = MCLep2.motherId;
            lep2GenCharge = MCLep2.charge;
          }
        }

        lep2IsGlobalMuon = muonsSelected.at(1).isGlobalMuon;
        lep2IsTrackerMuon = muonsSelected.at(1).isTrackerMuon;
        lep2IsGlobalMuonPromptTight = muonsSelected.at(1).isGlobalMuonPromptTight;
        lep2NumTrackHits = muonsSelected.at(1).numberOfValidTrackerHitsInnerTrack;
        lep2NumPixelHits = muonsSelected.at(1).pixelLayersWithMeasurement;
        lep2NumberOfMatches = muonsSelected.at(1).numberOfMatchedStations;

        if (selectionYearStr == "2011") {
          lep1Iso = (muonsSelected.at(0).chargedHadronIso
                      + muonsSelected.at(0).neutralHadronIso
                      + muonsSelected.at(0).photonIso) * 1.0 / lep1Pt;
          lep2Iso = (muonsSelected.at(1).chargedHadronIso
                      + muonsSelected.at(1).neutralHadronIso
                      + muonsSelected.at(1).photonIso) * 1.0 / lep2Pt;

          lep1ChargedIso = muonsSelected.at(0).chargedHadronIso / lep1Pt;
          lep2ChargedIso = muonsSelected.at(1).chargedHadronIso / lep2Pt;
        }
        else if (selectionYearStr == "2012_52x" || selectionYearStr == "2012_53x") {
          lep1Iso = (muonsSelected.at(0).pfIsoR04SumChargedHadronPt
                      + max(0.0, muonsSelected.at(0).pfIsoR04SumNeutralHadronEt
                                 + muonsSelected.at(0).pfIsoR04SumPhotonEt
                                 - 0.5*muonsSelected.at(0).pfIsoR04SumPUPt)) * 1.0 /lep1Pt;
          lep2Iso = (muonsSelected.at(1).pfIsoR04SumChargedHadronPt
                      + max(0.0, muonsSelected.at(1).pfIsoR04SumNeutralHadronEt
                                 + muonsSelected.at(1).pfIsoR04SumPhotonEt
                                 - 0.5*muonsSelected.at(1).pfIsoR04SumPUPt)) * 1.0 /lep2Pt;

          lep1ChargedIso = muonsSelected.at(0).pfIsoR04SumChargedHadronPt /lep1Pt;
          lep2ChargedIso = muonsSelected.at(1).pfIsoR04SumChargedHadronPt /lep2Pt;
        }
        else {
          assert (selectionYearStr == "either 2012_52x, 2012_53x, or 2011");
        }
        lep1NeutralIso = lep1Iso - lep1ChargedIso;
        lep2NeutralIso = lep2Iso - lep2ChargedIso;

        lep_vect1.SetPxPyPzE(muonsSelected.at(0).px, muonsSelected.at(0).py, muonsSelected.at(0).pz, muonsSelected.at(0).energy);
	    lep_vect2.SetPxPyPzE(muonsSelected.at(1).px, muonsSelected.at(1).py, muonsSelected.at(1).pz, muonsSelected.at(1).energy);
        lep_vect1_transverse.SetPxPyPzE(muonsSelected.at(0).px, muonsSelected.at(0).py,
                                        0.0, muonsSelected.at(0).pt);
        lep_vect2_transverse.SetPxPyPzE(muonsSelected.at(1).px, muonsSelected.at(1).py,
                                        0.0, muonsSelected.at(1).pt);

        if (isData) { lep1FlipSF = 1.0; lep1FlipSFUp = 1.0; lep1FlipSFDown = 1.0;
          lep2FlipSF = 1.0; lep2FlipSFUp = 1.0; lep2FlipSFDown = 1.0;
          lep1PromptSF = 1.0; lep1PromptSFUp = 1.0; lep1PromptSFDown = 1.0;
          lep2PromptSF = 1.0; lep2PromptSFUp = 1.0; lep2PromptSFDown = 1.0; }
        else {
          lep1FlipSF = 1.0; lep1FlipSFUp = 1.0; lep1FlipSFDown = 1.0;
          lep2FlipSF = 1.0; lep2FlipSFUp = 1.0; lep2FlipSFDown = 1.0;

          if (((lep1GenMotherID == lep1GenID && (abs(lep1GenID) == 11 || abs(lep1GenID) == 13)) || abs(lep1GenMotherID) == 15 ||
               abs(lep1GenMotherID) == 23 || abs(lep1GenMotherID) == 24 || abs(lep1GenMotherID) == 25 ) && abs(lep1GenID)>5) {
            lep1PromptSF = 1.0; lep1PromptSFUp = 1.0; lep1PromptSFDown = 1.0; lep1IsPrompt = 1;}
          else {
            lep1IsPrompt = 0;
            if (lep1ChargedIso <= 0.001) {
              lep1PromptSF = 3.0;
              lep1PromptSFUp = 3.5;
              lep1PromptSFDown = 2.5;
            }
            else {
              lep1PromptSF = 1.5;
              lep1PromptSFUp = 1.8;
              lep1PromptSFDown = 1.2;
            }
          }
          if (((lep2GenMotherID == lep2GenID && (abs(lep2GenID) == 11 || abs(lep2GenID) == 13)) || abs(lep2GenMotherID) == 15 ||
               abs(lep2GenMotherID) == 23 || abs(lep2GenMotherID) == 24 || abs(lep2GenMotherID) == 25 ) && abs(lep2GenID)>5) {
            lep2PromptSF = 1.0; lep2PromptSFUp = 1.0; lep2PromptSFDown = 1.0; lep2IsPrompt = 1; }
          else {
            lep2IsPrompt = 0;
            if (lep2ChargedIso <= 0.001) {
              lep2PromptSF = 3.0;
              lep2PromptSFUp = 3.5;
              lep2PromptSFDown = 2.5;
            }
            else {
              lep2PromptSF = 1.5;
              lep2PromptSFUp = 1.8;
              lep2PromptSFDown = 1.2;
            }
          }

        } // End if not data
        
        lep1PassSSCut = (muonsSelected.at(0).numberOfValidTrackerHitsInnerTrack > 7);
        lep2PassSSCut = (muonsSelected.at(1).numberOfValidTrackerHitsInnerTrack > 7);

        lep1Flavor = 13;
        lep2Flavor = 13;

	  }

	  if( twoTightEle || TightEleLooseEle ) {

        electronID::electronID firstLep = electronID::electronTight;
        electronID::electronID secondLep =
          (TightEleLooseEle) ? electronID::electronLoose : electronID::electronTight;
        
        lep1SF = beanHelper.GetElectronSF(electronsSelected.at(0), firstLep);
        lep2SF = beanHelper.GetElectronSF(electronsSelected.at(1), secondLep);

        if (debug_) cout << "DEBUG: Calling double ele trigger... ";
        triggerSF = beanHelper.GetDoubleElectronTriggerSF(electronsSelected.at(0),electronsSelected.at(1));
        if (debug_) cout << "RETURNED" << endl;

        //newSingleEleSF = beanHelper.TestSingleEleTriggerNew(electronsSelected.at(0));
        //oldSingleEleSF = beanHelper.TestSingleEleTriggerOld(electronsSelected.at(0));
	  
	    lep1Pt = electronsSelected.at(0).pt;
	    lep2Pt = electronsSelected.at(1).pt;
	    
	    lep1_et = electronsSelected.at(0).et;
	    lep2_et = electronsSelected.at(1).et;  

	    lep1Eta = electronsSelected.at(0).eta;
	    lep2Eta = electronsSelected.at(1).eta;  

	    lep1Phi = electronsSelected.at(0).phi;
	    lep2Phi = electronsSelected.at(1).phi;  

        lep1_tkDZ = electronsSelected.at(0).tkDZ;
        lep2_tkDZ = electronsSelected.at(1).tkDZ;

        lep1_correctedDZ = electronsSelected.at(0).correctedDZ;
        lep2_correctedDZ = electronsSelected.at(1).correctedDZ;

        lep1_correctedD0 = electronsSelected.at(0).correctedD0;
        lep2_correctedD0 = electronsSelected.at(1).correctedD0;
        
        lep1IP = electronsSelected.at(0).IP;
        lep2IP = electronsSelected.at(1).IP;
        
        lep1IPError = electronsSelected.at(0).IPError;
        lep2IPError = electronsSelected.at(1).IPError;
        
        lep1dFracScEtTkPt = fabs(electronsSelected.at(0).scEt - electronsSelected.at(0).tkPT)/electronsSelected.at(0).scEt;
        lep2dFracScEtTkPt = fabs(electronsSelected.at(1).scEt - electronsSelected.at(1).tkPT)/electronsSelected.at(1).scEt;
        
        lep1TkCharge = electronsSelected.at(0).tkCharge;
        lep2TkCharge = electronsSelected.at(1).tkCharge;

        lep1GsfCharge = electronsSelected.at(0).gsfCharge;
        lep2GsfCharge = electronsSelected.at(1).gsfCharge;

        lep1GenID = electronsSelected.at(0).genId;
        lep2GenID = electronsSelected.at(1).genId;

        lep1GenMotherID = electronsSelected.at(0).genMotherId;
        lep2GenMotherID = electronsSelected.at(1).genMotherId;

        lep1GenCharge = electronsSelected.at(0).genCharge;
        lep2GenCharge = electronsSelected.at(1).genCharge;

        if (lep1GenID == -99) {
          MCLep1 = beanHelper.GetMatchedMCparticle(mcparticles,electronsSelected.at(0),0.1);
          if (MCLep1.id != -99 && abs(MCLep1.id) != 6 && abs(MCLep1.id) != 23 && abs(MCLep1.id) != 24 && abs(MCLep1.id) != 25) {
            lep1GenID = MCLep1.id;
            lep1GenMotherID = MCLep1.motherId;
            lep1GenCharge = MCLep1.charge;
          }
        }
        if (lep2GenID == -99) {
          MCLep2 = beanHelper.GetMatchedMCparticle(mcparticles,electronsSelected.at(1),0.1);
          if (MCLep2.id != -99 && abs(MCLep2.id) != 6 && abs(MCLep2.id) != 23 && abs(MCLep2.id) != 24 && abs(MCLep2.id) != 25) {
            lep2GenID = MCLep2.id;
            lep2GenMotherID = MCLep2.motherId;
            lep2GenCharge = MCLep2.charge;
          }
        }
        
        if (selectionYearStr == "2011") {
          lep1Iso = (electronsSelected.at(0).chargedHadronIso
                      + electronsSelected.at(0).neutralHadronIso
                      + electronsSelected.at(0).photonIso) * 1.0 / lep1Pt;
          lep2Iso = (electronsSelected.at(1).chargedHadronIso
                      + electronsSelected.at(1).neutralHadronIso
                      + electronsSelected.at(1).photonIso) * 1.0 / lep2Pt;
        }
        else if (selectionYearStr == "2012_52x" || selectionYearStr == "2012_53x") {
          lep1Iso = ( electronsSelected.at(0).chargedHadronIso
                       + max(0.0, electronsSelected.at(0).neutralHadronIso
                                  + electronsSelected.at(0).photonIso
                                  - electronsSelected.at(0).AEffDr03*electronsSelected.at(0).rhoPrime) ) * 1.0 /lep1Pt;
          lep2Iso = ( electronsSelected.at(1).chargedHadronIso
                       + max(0.0, electronsSelected.at(1).neutralHadronIso
                                  + electronsSelected.at(1).photonIso
                                  - electronsSelected.at(1).AEffDr03*electronsSelected.at(1).rhoPrime) ) * 1.0 /lep2Pt;

        }
        else {
          assert (selectionYearStr == "either 2012_52x, 2012_53x, or 2011");
        }
        lep1ChargedIso = electronsSelected.at(0).chargedHadronIso /lep1Pt;
        lep2ChargedIso = electronsSelected.at(1).chargedHadronIso /lep2Pt;

        lep1NeutralIso = lep1Iso - lep1ChargedIso;
        lep2NeutralIso = lep2Iso - lep2ChargedIso;


	    lep_vect1.SetPxPyPzE(electronsSelected.at(0).px, electronsSelected.at(0).py, electronsSelected.at(0).pz, electronsSelected.at(0).energy);
	    lep_vect2.SetPxPyPzE(electronsSelected.at(1).px, electronsSelected.at(1).py, electronsSelected.at(1).pz, electronsSelected.at(1).energy);
        lep_vect1_transverse.SetPxPyPzE(electronsSelected.at(0).px, electronsSelected.at(0).py,
                                        0.0, electronsSelected.at(0).pt);
	    lep_vect2_transverse.SetPxPyPzE(electronsSelected.at(1).px, electronsSelected.at(1).py,
                                        0.0, electronsSelected.at(1).pt);

        lep2NumTrackHits = electronsSelected.at(1).tkNumValidHits;
        lep2NumPixelHits = electronsSelected.at(1).numberOfValidPixelBarrelHits + electronsSelected.at(1).numberOfValidPixelEndcapHits;
        lep2NumberOfMatches = electronsSelected.at(1).numClusters;
        lep2Chi2 = electronsSelected.at(1).tkNormChi2;
        lep2NumExpectedHits = electronsSelected.at(1).numberOfExpectedInnerHits;

        lep1PassSSCut = ( (lep1TkCharge == lep1GsfCharge) && (fabs(lep1IP) < 0.02) &&
                          (fabs(lep1_correctedD0 - lep2_correctedD0) < 0.015) &&
                          (lep1dFracScEtTkPt < 1) );
        lep2PassSSCut = ( (lep2TkCharge == lep2GsfCharge) && (fabs(lep2IP) < 0.02) &&
                          (fabs(lep1_correctedD0 - lep2_correctedD0) < 0.015) &&
                          (lep2dFracScEtTkPt < 1) );

        lep1Flavor = 11;
        lep2Flavor = 11;
        
        if (isData) { lep1FlipSF = 1.0; lep1FlipSFUp = 1.0; lep1FlipSFDown = 1.0;
          lep2FlipSF = 1.0; lep2FlipSFUp = 1.0; lep2FlipSFDown = 1.0;
          lep1PromptSF = 1.0; lep1PromptSFUp = 1.0; lep1PromptSFDown = 1.0;
          lep2PromptSF = 1.0; lep2PromptSFUp = 1.0; lep2PromptSFDown = 1.0; }
        else {
          lep1FlipSF = 1.0 + (lep1GsfCharge == -1*lep1GenCharge && lep1PassSSCut) * 0.1;
          lep1FlipSFUp = 1.0 + (lep1GsfCharge == -1*lep1GenCharge && lep1PassSSCut) * 0.3;
          lep1FlipSFDown = 1.0 + (lep1GsfCharge == -1*lep1GenCharge && lep1PassSSCut) * -0.1;
          lep2FlipSF = 1.0 + (lep2GsfCharge == -1*lep2GenCharge && lep2PassSSCut) * 0.1;
          lep2FlipSFUp = 1.0 + (lep2GsfCharge == -1*lep2GenCharge && lep2PassSSCut) * 0.3;
          lep2FlipSFDown = 1.0 + (lep2GsfCharge == -1*lep2GenCharge && lep2PassSSCut) * -0.1;

          if (((lep1GenMotherID == lep1GenID && (abs(lep1GenID) == 11 || abs(lep1GenID) == 13)) || abs(lep1GenMotherID) == 15 ||
               abs(lep1GenMotherID) == 23 || abs(lep1GenMotherID) == 24 || abs(lep1GenMotherID) == 25 ) && abs(lep1GenID)>5) {
            lep1PromptSF = 1.0; lep1PromptSFUp = 1.0; lep1PromptSFDown = 1.0; lep1IsPrompt = 1;}
          else {
            lep1IsPrompt = 0;
            if (lep1ChargedIso <= 0.001) {
              lep1PromptSF = 2.5;
              lep1PromptSFUp = 2.9;
              lep1PromptSFDown = 2.1;
            }
            else {
              lep1PromptSF = 1.7;
              lep1PromptSFUp = 2.0;
              lep1PromptSFDown = 1.4;
            }
          }
          if (((lep2GenMotherID == lep2GenID && (abs(lep2GenID) == 11 || abs(lep2GenID) == 13)) || abs(lep2GenMotherID) == 15 ||
               abs(lep2GenMotherID) == 23 || abs(lep2GenMotherID) == 24 || abs(lep2GenMotherID) == 25 ) && abs(lep2GenID)>5) {
            lep2PromptSF = 1.0; lep2PromptSFUp = 1.0; lep2PromptSFDown = 1.0; lep2IsPrompt = 1; }
          else {
            lep2IsPrompt = 0;
            if (lep2ChargedIso <= 0.001) {
              lep2PromptSF = 2.5;
              lep2PromptSFUp = 2.9;
              lep2PromptSFDown = 2.1;
            }
            else {
              lep2PromptSF = 1.7;
              lep2PromptSFUp = 2.0;
              lep2PromptSFDown = 1.4;
            }
          }
        } // End if not data
        
	  }

      // This is the case where the muon is higher pt than the
      // electron
	  if( (oneEleOneMuonTight || TightEleLooseMuon || TightMuonLooseEle) &&
          (muonsSelected.at(0).pt >= electronsSelected.at(0).pt ) ) {

        muonID::muonID  theMuonType = (oneEleOneMuonTight || TightMuonLooseEle) ? muonID::muonTight : muonID::muonLoose;
        electronID::electronID  theEleType  =
          (oneEleOneMuonTight || TightEleLooseMuon) ? electronID::electronTight : electronID::electronLoose;
        
        lep1SF = beanHelper.GetMuonSF(muonsSelected.at(0), theMuonType);
        lep2SF = beanHelper.GetElectronSF(electronsSelected.at(0), theEleType);


        if (debug_) cout << "DEBUG Calling muon ele trigger SF ... ";
        triggerSF = beanHelper.GetMuonEleTriggerSF(muonsSelected.at(0), electronsSelected.at(0));
        if (debug_) cout << "RETURNEd!" << endl;

        //newSingleEleSF = beanHelper.TestSingleEleTriggerNew(electronsSelected.at(0));
        //oldSingleEleSF = beanHelper.TestSingleEleTriggerOld(electronsSelected.at(0));

        //newSingleMuSF = beanHelper.TestSingleMuonTriggerNew(muonsSelected.at(0));
        //oldSingleMuSF = beanHelper.TestSingleMuonTriggerOld(muonsSelected.at(0));

	    lep1Pt = muonsSelected.at(0).pt;
	    lep2Pt = electronsSelected.at(0).pt;
	    
	    lep1_et = muonsSelected.at(0).et;
	    lep2_et = electronsSelected.at(0).et;  

	    lep1Eta = muonsSelected.at(0).eta;
	    lep2Eta = electronsSelected.at(0).eta;  

	    lep1Phi = muonsSelected.at(0).phi;
	    lep2Phi = electronsSelected.at(0).phi;  

        lep1_tkDZ = muonsSelected.at(0).tkDZ;
        lep2_tkDZ = electronsSelected.at(0).tkDZ;

        lep1_correctedDZ = muonsSelected.at(0).correctedDZ;
        lep2_correctedDZ = electronsSelected.at(0).correctedDZ;

        lep1_correctedD0 = muonsSelected.at(0).correctedD0;
        lep2_correctedD0 = electronsSelected.at(0).correctedD0;
        
        lep1IP = muonsSelected.at(0).IP;
        lep2IP = electronsSelected.at(0).IP;

        lep1IPError = muonsSelected.at(0).IPError;
        lep2IPError = electronsSelected.at(0).IPError;

        lep2dFracScEtTkPt = fabs(electronsSelected.at(0).scEt - electronsSelected.at(0).tkPT)/electronsSelected.at(0).scEt;
        
        lep1TkCharge = muonsSelected.at(0).tkCharge;
        lep2TkCharge = electronsSelected.at(0).tkCharge;

        lep2GsfCharge = electronsSelected.at(0).gsfCharge;

        lep1GenID = muonsSelected.at(0).genId;
        lep2GenID = electronsSelected.at(0).genId;

        lep1GenMotherID = muonsSelected.at(0).genMotherId;
        lep2GenMotherID = electronsSelected.at(0).genMotherId;

        lep1GenCharge = muonsSelected.at(0).genCharge;
        lep2GenCharge = electronsSelected.at(0).genCharge;

        if (lep1GenID == -99) {
          MCLep1 = beanHelper.GetMatchedMCparticle(mcparticles,muonsSelected.at(0),0.1);
          if (MCLep1.id != -99 && abs(MCLep1.id) != 6 && abs(MCLep1.id) != 23 && abs(MCLep1.id) != 24 && abs(MCLep1.id) != 25) {
            lep1GenID = MCLep1.id;
            lep1GenMotherID = MCLep1.motherId;
            lep1GenCharge = MCLep1.charge;
          }
        }
        if (lep2GenID == -99) {
          MCLep2 = beanHelper.GetMatchedMCparticle(mcparticles,electronsSelected.at(0),0.1);
          if (MCLep2.id != -99 && abs(MCLep2.id) != 6 && abs(MCLep2.id) != 23 && abs(MCLep2.id) != 24 && abs(MCLep2.id) != 25) {
            lep2GenID = MCLep2.id;
            lep2GenMotherID = MCLep2.motherId;
            lep2GenCharge = MCLep2.charge;
          }
        }

        if (selectionYearStr == "2011") {
          lep1Iso = (muonsSelected.at(0).chargedHadronIso
                      + muonsSelected.at(0).neutralHadronIso
                      + muonsSelected.at(0).photonIso) * 1.0 / lep1Pt;
          lep2Iso = (electronsSelected.at(0).chargedHadronIso + electronsSelected.at(0).neutralHadronIso + electronsSelected.at(0).photonIso) * 1.0 / lep2Pt;

          lep1ChargedIso = muonsSelected.at(0).chargedHadronIso / lep1Pt;
          lep2ChargedIso = electronsSelected.at(0).chargedHadronIso / lep2Pt;
        }
        else if (selectionYearStr == "2012_52x" || selectionYearStr == "2012_53x") {
          lep1Iso = (muonsSelected.at(0).pfIsoR04SumChargedHadronPt
                      + max(0.0, muonsSelected.at(0).pfIsoR04SumNeutralHadronEt
                                 + muonsSelected.at(0).pfIsoR04SumPhotonEt
                                 - 0.5*muonsSelected.at(0).pfIsoR04SumPUPt)) * 1.0 /lep1Pt;
          lep2Iso = ( electronsSelected.at(0).chargedHadronIso
                       + max(0.0, electronsSelected.at(0).neutralHadronIso
                                  + electronsSelected.at(0).photonIso
                                  - electronsSelected.at(0).AEffDr03*electronsSelected.at(0).rhoPrime) ) * 1.0 /lep2Pt;
          lep1ChargedIso = muonsSelected.at(0).pfIsoR04SumChargedHadronPt /lep1Pt;
          lep2ChargedIso = electronsSelected.at(0).chargedHadronIso / lep2Pt;
        }
        else {
          assert (selectionYearStr == "either 2012_52x, 2012_53x, or 2011");
        }
        lep1NeutralIso = lep1Iso - lep1ChargedIso;
        lep2NeutralIso = lep2Iso - lep2ChargedIso;
        
	    lep_vect1.SetPxPyPzE(muonsSelected.at(0).px, muonsSelected.at(0).py, muonsSelected.at(0).pz, muonsSelected.at(0).energy);
	    lep_vect2.SetPxPyPzE(electronsSelected.at(0).px, electronsSelected.at(0).py, electronsSelected.at(0).pz, electronsSelected.at(0).energy);
        lep_vect1_transverse.SetPxPyPzE(muonsSelected.at(0).px, muonsSelected.at(0).py,
                                        0.0, muonsSelected.at(0).pt);
	    lep_vect2_transverse.SetPxPyPzE(electronsSelected.at(0).px, electronsSelected.at(0).py,
                                        0.0, electronsSelected.at(0).pt);

        lep1PassSSCut = muonsSelected.at(0).numberOfValidTrackerHitsInnerTrack > 7;
        lep2PassSSCut = ( (lep2TkCharge == lep2GsfCharge) && (fabs(lep2IP) < 0.02) &&
                          (fabs(lep1_correctedD0 - lep2_correctedD0) < 0.015) &&
                          (lep2dFracScEtTkPt < 1) );

        lep1Flavor = 13;
        lep2Flavor = 11;

        if (isData) { lep1FlipSF = 1.0; lep1FlipSFUp = 1.0; lep1FlipSFDown = 1.0;
          lep2FlipSF = 1.0; lep2FlipSFUp = 1.0; lep2FlipSFDown = 1.0;
          lep1PromptSF = 1.0; lep1PromptSFUp = 1.0; lep1PromptSFDown = 1.0;
          lep2PromptSF = 1.0; lep2PromptSFUp = 1.0; lep2PromptSFDown = 1.0; }
        else {
          lep1FlipSF = 1.0; lep1FlipSFUp = 1.0; lep1FlipSFDown = 1.0;
          lep2FlipSF = 1.0 + (lep2GsfCharge == -1*lep2GenCharge && lep2PassSSCut) * 0.1;
          lep2FlipSFUp = 1.0 + (lep2GsfCharge == -1*lep2GenCharge && lep2PassSSCut) * 0.3;
          lep2FlipSFDown = 1.0 + (lep2GsfCharge == -1*lep2GenCharge && lep2PassSSCut) * -0.1;

          if (((lep1GenMotherID == lep1GenID && (abs(lep1GenID) == 11 || abs(lep1GenID) == 13)) || abs(lep1GenMotherID) == 15 ||
               abs(lep1GenMotherID) == 23 || abs(lep1GenMotherID) == 24 || abs(lep1GenMotherID) == 25 ) && abs(lep1GenID)>5) {
            lep1PromptSF = 1.0; lep1PromptSFUp = 1.0; lep1PromptSFDown = 1.0; lep1IsPrompt = 1;}
          else {
            lep1IsPrompt = 0;
            if (lep1ChargedIso <= 0.001) {
              lep1PromptSF = 3.0;
              lep1PromptSFUp = 3.5;
              lep1PromptSFDown = 2.5;
            }
            else {
              lep1PromptSF = 1.5;
              lep1PromptSFUp = 1.8;
              lep1PromptSFDown = 1.2;
            }
          }
          if (((lep2GenMotherID == lep2GenID && (abs(lep2GenID) == 11 || abs(lep2GenID) == 13)) || abs(lep2GenMotherID) == 15 ||
               abs(lep2GenMotherID) == 23 || abs(lep2GenMotherID) == 24 || abs(lep2GenMotherID) == 25 ) && abs(lep2GenID)>5) {
            lep2PromptSF = 1.0; lep2PromptSFUp = 1.0; lep2PromptSFDown = 1.0; lep2IsPrompt = 1; }
          else {
            lep2IsPrompt = 0;
            if (lep2ChargedIso <= 0.001) {
              lep2PromptSF = 2.5;
              lep2PromptSFUp = 2.9;
              lep2PromptSFDown = 2.1;
            }
            else {
              lep2PromptSF = 1.7;
              lep2PromptSFUp = 2.0;
              lep2PromptSFDown = 1.4;
            }
          }
        } //End if not data

	  }

      // this is the case where the muon is lower pt than the electron
	  if( (oneEleOneMuonTight || TightEleLooseMuon || TightMuonLooseEle) &&
          (muonsSelected.at(0).pt < electronsSelected.at(0).pt ) ) {

        muonID::muonID  theMuonType = (oneEleOneMuonTight || TightMuonLooseEle) ? muonID::muonTight : muonID::muonLoose;
        electronID::electronID  theEleType  =
          (oneEleOneMuonTight || TightEleLooseMuon) ? electronID::electronTight : electronID::electronLoose;
        
        lep2SF = beanHelper.GetMuonSF(muonsSelected.at(0), theMuonType);
        lep1SF = beanHelper.GetElectronSF(electronsSelected.at(0), theEleType);

        if (debug_) cout << "DEBUG Calling muon ele trigger SF ... ";
        triggerSF = beanHelper.GetMuonEleTriggerSF(muonsSelected.at(0), electronsSelected.at(0));
        if (debug_) cout << "RETUrNEd!" << endl;

        //newSingleEleSF = beanHelper.TestSingleEleTriggerNew(electronsSelected.at(0));
        //oldSingleEleSF = beanHelper.TestSingleEleTriggerOld(electronsSelected.at(0));

        //newSingleMuSF = beanHelper.TestSingleMuonTriggerNew(muonsSelected.at(0));
        //oldSingleMuSF = beanHelper.TestSingleMuonTriggerOld(muonsSelected.at(0));

	    lep2Pt = muonsSelected.at(0).pt;
	    lep1Pt = electronsSelected.at(0).pt;
	    
	    lep2_et = muonsSelected.at(0).et;
	    lep1_et = electronsSelected.at(0).et;  

	    lep2Eta = muonsSelected.at(0).eta;
	    lep1Eta = electronsSelected.at(0).eta;  

	    lep2Phi = muonsSelected.at(0).phi;
	    lep1Phi = electronsSelected.at(0).phi;  

        lep2_tkDZ = muonsSelected.at(0).tkDZ;
        lep1_tkDZ = electronsSelected.at(0).tkDZ;

        lep2_correctedDZ = muonsSelected.at(0).correctedDZ;
        lep1_correctedDZ = electronsSelected.at(0).correctedDZ;

        lep2_correctedD0 = muonsSelected.at(0).correctedD0;
        lep1_correctedD0 = electronsSelected.at(0).correctedD0;
        
        lep2IP = muonsSelected.at(0).IP;
        lep1IP = electronsSelected.at(0).IP;

        lep2IPError = muonsSelected.at(0).IPError;
        lep1IPError = electronsSelected.at(0).IPError;

        lep1dFracScEtTkPt = fabs(electronsSelected.at(0).scEt - electronsSelected.at(0).tkPT)/electronsSelected.at(0).scEt;
        
        lep2TkCharge = muonsSelected.at(0).tkCharge;
        lep1TkCharge = electronsSelected.at(0).tkCharge;

        lep1GsfCharge = electronsSelected.at(0).gsfCharge;

        lep2GenID = muonsSelected.at(0).genId;
        lep1GenID = electronsSelected.at(0).genId;

        lep2GenMotherID = muonsSelected.at(0).genMotherId;
        lep1GenMotherID = electronsSelected.at(0).genMotherId;

        lep2GenCharge = muonsSelected.at(0).genCharge;
        lep1GenCharge = electronsSelected.at(0).genCharge;

        if (lep2GenID == -99) {
          MCLep2 = beanHelper.GetMatchedMCparticle(mcparticles,muonsSelected.at(0),0.1);
          if (MCLep2.id != -99 && abs(MCLep2.id) != 6 && abs(MCLep2.id) != 23 && abs(MCLep2.id) != 24 && abs(MCLep2.id) != 25) {
            lep2GenID = MCLep2.id;
            lep2GenMotherID = MCLep2.motherId;
            lep2GenCharge = MCLep2.charge;
          }
        }
        if (lep1GenID == -99) {
          MCLep1 = beanHelper.GetMatchedMCparticle(mcparticles,electronsSelected.at(0),0.1);
          if (MCLep1.id != -99 && abs(MCLep1.id) != 6 && abs(MCLep1.id) != 23 && abs(MCLep1.id) != 24 && abs(MCLep1.id) != 25) {
            lep1GenID = MCLep1.id;
            lep1GenMotherID = MCLep1.motherId;
            lep1GenCharge = MCLep1.charge;
          }
        }

        if (selectionYearStr == "2011") {
          lep2Iso = (muonsSelected.at(0).chargedHadronIso
                      + muonsSelected.at(0).neutralHadronIso
                      + muonsSelected.at(0).photonIso) * 1.0 / lep2Pt;
          lep1Iso = (electronsSelected.at(0).chargedHadronIso + electronsSelected.at(0).neutralHadronIso + electronsSelected.at(0).photonIso) * 1.0 / lep1Pt;

          lep2ChargedIso = muonsSelected.at(0).chargedHadronIso / lep2Pt;
          lep1ChargedIso = electronsSelected.at(0).chargedHadronIso / lep1Pt;
        }
        else if (selectionYearStr == "2012_52x" || selectionYearStr == "2012_53x") {
          lep2Iso = (muonsSelected.at(0).pfIsoR04SumChargedHadronPt
                      + max(0.0, muonsSelected.at(0).pfIsoR04SumNeutralHadronEt
                                 + muonsSelected.at(0).pfIsoR04SumPhotonEt
                                 - 0.5*muonsSelected.at(0).pfIsoR04SumPUPt)) * 1.0 /lep2Pt;
          lep1Iso = ( electronsSelected.at(0).chargedHadronIso
                       + max(0.0, electronsSelected.at(0).neutralHadronIso
                                  + electronsSelected.at(0).photonIso
                                  - electronsSelected.at(0).AEffDr03*electronsSelected.at(0).rhoPrime) ) * 1.0 /lep1Pt;
          lep2ChargedIso = muonsSelected.at(0).pfIsoR04SumChargedHadronPt /lep2Pt;
          lep1ChargedIso = electronsSelected.at(0).chargedHadronIso / lep1Pt;
        }
        else {
          assert (selectionYearStr == "either 2012_52x, 2012_53x, or 2011");
        }
        lep2NeutralIso = lep2Iso - lep2ChargedIso;
        lep1NeutralIso = lep1Iso - lep1ChargedIso;
        
	    lep_vect2.SetPxPyPzE(muonsSelected.at(0).px, muonsSelected.at(0).py, muonsSelected.at(0).pz, muonsSelected.at(0).energy);
	    lep_vect1.SetPxPyPzE(electronsSelected.at(0).px, electronsSelected.at(0).py, electronsSelected.at(0).pz, electronsSelected.at(0).energy);
        lep_vect2_transverse.SetPxPyPzE(muonsSelected.at(0).px, muonsSelected.at(0).py,
                                        0.0, muonsSelected.at(0).pt);
	    lep_vect1_transverse.SetPxPyPzE(electronsSelected.at(0).px, electronsSelected.at(0).py,
                                        0.0, electronsSelected.at(0).pt);

        lep2PassSSCut = muonsSelected.at(0).numberOfValidTrackerHitsInnerTrack > 7;
        lep1PassSSCut = ( (lep1TkCharge == lep1GsfCharge) && (fabs(lep1IP) < 0.02) &&
                          (fabs(lep1_correctedD0 - lep1_correctedD0) < 0.015) &&
                          (lep1dFracScEtTkPt < 1) );

        lep2Flavor = 13;
        lep1Flavor = 11;

        if (isData) { lep2FlipSF = 1.0; lep2FlipSFUp = 1.0; lep2FlipSFDown = 1.0;
          lep1FlipSF = 1.0; lep1FlipSFUp = 1.0; lep1FlipSFDown = 1.0;
          lep2PromptSF = 1.0; lep2PromptSFUp = 1.0; lep2PromptSFDown = 1.0;
          lep1PromptSF = 1.0; lep1PromptSFUp = 1.0; lep1PromptSFDown = 1.0; }
        else {
          lep2FlipSF = 1.0; lep2FlipSFUp = 1.0; lep2FlipSFDown = 1.0;
          lep1FlipSF = 1.0 + (lep1GsfCharge == -1*lep1GenCharge && lep1PassSSCut) * 0.1;
          lep1FlipSFUp = 1.0 + (lep1GsfCharge == -1*lep1GenCharge && lep1PassSSCut) * 0.3;
          lep1FlipSFDown = 1.0 + (lep1GsfCharge == -1*lep1GenCharge && lep1PassSSCut) * -0.1;

          if (((lep2GenMotherID == lep2GenID && (abs(lep2GenID) == 11 || abs(lep2GenID) == 13)) || abs(lep2GenMotherID) == 15 ||
               abs(lep2GenMotherID) == 23 || abs(lep2GenMotherID) == 24 || abs(lep2GenMotherID) == 25 ) && abs(lep2GenID)>5) {
            lep2PromptSF = 1.0; lep2PromptSFUp = 1.0; lep2PromptSFDown = 1.0; lep2IsPrompt = 1; }
          else {
            lep2IsPrompt = 0;
            if (lep2ChargedIso <= 0.001) {
              lep2PromptSF = 3.0;
              lep2PromptSFUp = 3.5;
              lep2PromptSFDown = 2.5;
            }
            else {
              lep2PromptSF = 1.5;
              lep2PromptSFUp = 1.8;
              lep2PromptSFDown = 1.2;
            }
          }
          if (((lep1GenMotherID == lep1GenID && (abs(lep1GenID) == 11 || abs(lep1GenID) == 13)) || abs(lep1GenMotherID) == 15 ||
               abs(lep1GenMotherID) == 23 || abs(lep1GenMotherID) == 24 || abs(lep1GenMotherID) == 25 ) && abs(lep1GenID)>5) {
            lep1PromptSF = 1.0; lep1PromptSFUp = 1.0; lep1PromptSFDown = 1.0; lep1IsPrompt = 1;}
          else {
            lep1IsPrompt = 0;
            if (lep1ChargedIso <= 0.001) {
              lep1PromptSF = 2.5;
              lep1PromptSFUp = 2.9;
              lep1PromptSFDown = 2.1;
            }
            else {
              lep1PromptSF = 1.7;
              lep1PromptSFUp = 2.0;
              lep1PromptSFDown = 1.4;
            }
          }
        } //End if not data

	  }

          
      if ( (abs(lep1GenID/100)%10 == 5) || (abs(lep1GenID/1000)%10 == 5))      lep1GenID = 5*lep1GenID/abs(lep1GenID);
      else if ( (abs(lep1GenID/100)%10 == 4) || (abs(lep1GenID/1000)%10 == 4)) lep1GenID = 4*lep1GenID/abs(lep1GenID);
      else if ( (abs(lep1GenID/100)%10 == 3) || (abs(lep1GenID/1000)%10 == 3)) lep1GenID = 3*lep1GenID/abs(lep1GenID);
      else if ( (abs(lep1GenID/100)%10 == 2) || (abs(lep1GenID/1000)%10 == 2)) lep1GenID = 2*lep1GenID/abs(lep1GenID);
      else if ( (abs(lep1GenID/100)%10 == 1) || (abs(lep1GenID/1000)%10 == 1)) lep1GenID = 1*lep1GenID/abs(lep1GenID);
      
      if ( (abs(lep2GenID/100)%10 == 5) || (abs(lep2GenID/1000)%10 == 5))      lep2GenID = 5*lep2GenID/abs(lep2GenID);
      else if ( (abs(lep2GenID/100)%10 == 4) || (abs(lep2GenID/1000)%10 == 4)) lep2GenID = 4*lep2GenID/abs(lep2GenID);
      else if ( (abs(lep2GenID/100)%10 == 3) || (abs(lep2GenID/1000)%10 == 3)) lep2GenID = 3*lep2GenID/abs(lep2GenID);
      else if ( (abs(lep2GenID/100)%10 == 2) || (abs(lep2GenID/1000)%10 == 2)) lep2GenID = 2*lep2GenID/abs(lep2GenID);
      else if ( (abs(lep2GenID/100)%10 == 1) || (abs(lep2GenID/1000)%10 == 1)) lep2GenID = 1*lep2GenID/abs(lep2GenID);

      if ( (abs(lep1GenMotherID/100)%10 == 5) || (abs(lep1GenMotherID/1000)%10 == 5))      lep1GenMotherID = 5*lep1GenMotherID/abs(lep1GenMotherID);
      else if ( (abs(lep1GenMotherID/100)%10 == 4) || (abs(lep1GenMotherID/1000)%10 == 4)) lep1GenMotherID = 4*lep1GenMotherID/abs(lep1GenMotherID);
      else if ( (abs(lep1GenMotherID/100)%10 == 3) || (abs(lep1GenMotherID/1000)%10 == 3)) lep1GenMotherID = 3*lep1GenMotherID/abs(lep1GenMotherID);
      else if ( (abs(lep1GenMotherID/100)%10 == 2) || (abs(lep1GenMotherID/1000)%10 == 2)) lep1GenMotherID = 2*lep1GenMotherID/abs(lep1GenMotherID);
      else if ( (abs(lep1GenMotherID/100)%10 == 1) || (abs(lep1GenMotherID/1000)%10 == 1)) lep1GenMotherID = 1*lep1GenMotherID/abs(lep1GenMotherID);

      if ( (abs(lep2GenMotherID/100)%10 == 5) || (abs(lep2GenMotherID/1000)%10 == 5))      lep2GenMotherID = 5*lep2GenMotherID/abs(lep2GenMotherID);
      else if ( (abs(lep2GenMotherID/100)%10 == 4) || (abs(lep2GenMotherID/1000)%10 == 4)) lep2GenMotherID = 4*lep2GenMotherID/abs(lep2GenMotherID);
      else if ( (abs(lep2GenMotherID/100)%10 == 3) || (abs(lep2GenMotherID/1000)%10 == 3)) lep2GenMotherID = 3*lep2GenMotherID/abs(lep2GenMotherID);
      else if ( (abs(lep2GenMotherID/100)%10 == 2) || (abs(lep2GenMotherID/1000)%10 == 2)) lep2GenMotherID = 2*lep2GenMotherID/abs(lep2GenMotherID);
      else if ( (abs(lep2GenMotherID/100)%10 == 1) || (abs(lep2GenMotherID/1000)%10 == 1)) lep2GenMotherID = 1*lep2GenMotherID/abs(lep2GenMotherID);
      
      float lepTotalSF = lep1SF * lep2SF;
      float lepTotalFlipSF = lep1FlipSF*lep2FlipSF;
      float lepTotalFlipSFUp = lep1FlipSFUp*lep2FlipSFUp;
      float lepTotalFlipSFDown = lep1FlipSFDown*lep2FlipSFDown;
      float lepTotalPromptSF = lep1PromptSF*lep2PromptSF;
      float lepTotalPromptSFUp = lep1PromptSFUp*lep2PromptSFUp;
      float lepTotalPromptSFDown = lep1PromptSFDown*lep2PromptSFDown;
      int lepTotalPassSSCut = 1 * ( lep1PassSSCut == 1 && lep2PassSSCut == 1);
      
      if (verbose) std::cout << "about to fill two lep vars " <<std::endl
                             << "TwoMuon = " << TwoMuon << " twoTightMuon = " << twoTightMuon << " TightMuonLooseMuon = " << TightMuonLooseMuon   << endl
                             << "TwoEle = " << TwoEle  << " twoTightEle = " << twoTightEle << " TightEleLooseEle  " << TightEleLooseEle << endl
                             << "MuonEle = " << MuonEle << " TightMuonLooseEle = " << TightMuonLooseEle << " TightEleLooseMuon = " << TightEleLooseMuon << " oneEleOneMuonTight = " << endl
                             << "lep1SF = " << lep1SF << " lep2SF = " << lep2SF   << " lepTotalSF = " << lepTotalSF
                             << endl;
        
        


      
      
      int oppositeLepCharge = dInt;
      int oppositeGenLepCharge = dInt;
      // check to see if the product is negative
      // it can only be negative if the charges
      // have opposite signs
      if ((lep1TkCharge * lep2TkCharge) == -1) {
        oppositeLepCharge = 1;
      } else if ((lep1TkCharge * lep2TkCharge) == 1) {
        oppositeLepCharge = 0;
      } else if (fabs(lep2TkCharge) == 99) {
        oppositeLepCharge = -1;
      } else if (fabs(lep1TkCharge) == 99) {
        oppositeLepCharge = -2;
      }
      else {
        if (debug_) std::cout << "Lep1 has charge " << lep1TkCharge << " and Lep2 has charge " << lep2TkCharge << std::endl;
      }
      if (applySelectionSameSign) {
        if (oppositeLepCharge == 1) continue;
      }

      if ((lep1GenCharge * lep2GenCharge) == -1) {
        oppositeGenLepCharge = 1;
      } else if ((lep1GenCharge * lep2GenCharge) == 1) {
        oppositeGenLepCharge = 0;
      } else if (fabs(lep2GenCharge) == 99) {
        oppositeGenLepCharge = -1;
      } else if (fabs(lep1GenCharge) == 99) {
        oppositeGenLepCharge = -2;
      }
      else {
        if (debug_) std::cout << "Lep1 has charge " << lep1GenCharge << " and Lep2 has charge " << lep2GenCharge << std::endl;
      }

      if (debug_) std::cout << "Finished with leptons" << std::endl;
      
      if (sum_pt == dFloat) sum_pt = 0.0;
      if (Ht == dFloat) Ht = 0.0;
	  sum_pt += lep1Pt;
	  Ht += lep1_et ;

	  sum_pt += lep2Pt;
	  Ht += lep2_et ;
	  
	  // two leptons
	  TLorentzVector two_lepton_vect = lep_vect1 + lep_vect2;
	  TLorentzVector two_lepton_vect_transverse = lep_vect1_transverse + lep_vect2_transverse;
      TLorentzVector met_lep1_vect = metV + lep_vect1_transverse;
      TLorentzVector met_lep2_vect = metV + lep_vect2_transverse;
      TLorentzVector met_leplep_vect = metV + two_lepton_vect;
      TLorentzVector met_leplep_vect_transverse = metV + two_lepton_vect_transverse;

      float MT_met_lep1 = met_lep1_vect.M();
      float MT_met_lep2 = met_lep2_vect.M();
      float mass_met_leplep = met_leplep_vect.M();
      float MT_met_leplep = met_leplep_vect_transverse.M();
      
      float dPhi_met_lep1 = lep_vect1.DeltaPhi(metV);
      float dPhi_met_lep2 = lep_vect2.DeltaPhi(metV);
	  float mass_leplep = two_lepton_vect.M();
	  float MT_leplep = two_lepton_vect_transverse.M();
	  float pt_leplep = two_lepton_vect.Pt();
	  float dPhi_leplep = lep_vect1.DeltaPhi(lep_vect2);
	  float dR_leplep = lep_vect1.DeltaR(lep_vect2);
      float dEta_leplep = lep_vect1.Eta() - lep_vect2.Eta();
      float correctedDZ_leplep = lep1_correctedDZ - lep2_correctedDZ;
      float correctedD0_leplep = lep1_correctedD0 - lep2_correctedD0;
      float tkDZ_leplep = lep1_tkDZ - lep2_tkDZ;

	  TLorentzVector everything_vect = metV + lep_vect1 + lep_vect2 + sum_jet_vect;
      TLorentzVector leps_and_jets_vect = lep_vect1 + lep_vect2 + sum_jet_vect;
      TLorentzVector leps_and_jets_vect_transverse;
      leps_and_jets_vect_transverse.SetPxPyPzE(-leps_and_jets_vect.Px(),
                                               -leps_and_jets_vect.Py(),
                                               0.0,leps_and_jets_vect.Pt());
      TLorentzVector leps_and_allJets_vect = lep_vect1 + lep_vect2 + sum_allJet_vect;
      TLorentzVector allEverything_vect = leps_and_allJets_vect + metV;
      TLorentzVector MHT_leplep_vect = leps_and_jets_vect_transverse + two_lepton_vect;
      TLorentzVector MHT_leplep_vect_transverse = leps_and_jets_vect_transverse + two_lepton_vect_transverse;
      TLorentzVector MHT_lep1_vect = lep_vect1_transverse + leps_and_jets_vect_transverse;
      TLorentzVector MHT_lep2_vect = lep_vect2_transverse + leps_and_jets_vect_transverse;

      float mass_of_everything = everything_vect.M();
      float mass_MHT = leps_and_jets_vect.M();
      float mass_of_leps_and_allJets = leps_and_allJets_vect.M();
      float pt_of_everything = everything_vect.Pt();
      float pz_of_everything = everything_vect.Pz();
      float MHT = leps_and_jets_vect.Pt();
      float pt_of_leps_and_allJets = leps_and_allJets_vect.Pt();
      float pt_of_allEverything = allEverything_vect.Pt();
      float mass_MHT_leplep = MHT_leplep_vect.M();
      float MT_MHT_leplep = MHT_leplep_vect_transverse.M();
      float MT_MHT_lep1 = MHT_lep1_vect.M();
      float MT_MHT_lep2 = MHT_lep2_vect.M();

      if (debug_) std::cout << "Finished setting vectors" << std::endl;

      TLorentzVector MHT_lep1_b1_vect;
      TLorentzVector MHT_lep2_b1_vect;
      TLorentzVector met_lep1_b1_vect;
      TLorentzVector met_lep2_b1_vect;
      TLorentzVector lep1_b1_vect;
      TLorentzVector lep2_b1_vect;
      TLorentzVector MHT_lep1_b2_vect;
      TLorentzVector MHT_lep2_b2_vect;
      TLorentzVector met_lep1_b2_vect;
      TLorentzVector met_lep2_b2_vect;
      TLorentzVector lep1_b2_vect;
      TLorentzVector lep2_b2_vect;

      TLorentzVector ttbar_vect;
      TLorentzVector bjet1_vect;
      TLorentzVector bjet2_vect;

      /// pt of ttbar
      float pt_of_ttbar = dFloat;

	  ///loop jet

      if (debug_) std::cout << "Beginning loop over allJets" << std::endl;

      for (int i=0; i<numGoodAndBadJets; i++) {
        if (jet_energy[i] < 0.1) continue;
        allJet_vect.SetPxPyPzE(jet_px[i],jet_py[i],jet_pz[i],jet_energy[i]);

        if (HtoBB == 1) {
          if (higgsGenBV[0].DeltaR(allJet_vect) < min_dr_genB1_allJet || min_dr_genB1_allJet == dFloat) {
            min_dr_genB1_allJet = higgsGenBV[0].DeltaR(allJet_vect);
          }
          if (higgsGenBV[1].DeltaR(allJet_vect) < min_dr_genB2_allJet || min_dr_genB2_allJet == dFloat) {
            min_dr_genB2_allJet = higgsGenBV[1].DeltaR(allJet_vect);
          }
        }

	    if (i==0)  first_allJet_pt = jet_pt[i];
	    if (i==1)  second_allJet_pt = jet_pt[i];
	    if (i==2)  third_allJet_pt = jet_pt[i];
	    if (i==3)  fourth_allJet_pt = jet_pt[i];
        
	    if (mindr_lep1_allJet > lep_vect1.DeltaR(allJet_vect) || mindr_lep1_allJet == dFloat){
	      mindr_lep1_allJet = lep_vect1.DeltaR(allJet_vect);
          ptRel_lep1_allJet = lep_vect1.Pt() / (lep_vect1.Pt() + allJet_vect.Pt());
	    }

	    if (mindr_lep2_allJet > lep_vect2.DeltaR(allJet_vect) || mindr_lep2_allJet == dFloat){
	      mindr_lep2_allJet = lep_vect2.DeltaR(allJet_vect); 
          ptRel_lep2_allJet = lep_vect2.Pt() / (lep_vect2.Pt() + allJet_vect.Pt());
	    }

        for (int j=i+1; j < numGoodAndBadJets; j++) {
          sum_higgsLike_allDijet_vect = allJetV[i] + allJetV[j];
          higgsLike_allDijet_mass2 = sum_higgsLike_allDijet_vect.M();
          if (pfjetsSelected.at(i).btagCombinedSecVertex > btagThres
              || pfjetsSelected.at(j).btagCombinedSecVertex > btagThres) {
            if (fabs(higgs_mass - higgsLike_allDijet_mass1) > fabs(higgs_mass - higgsLike_allDijet_mass2)
                || higgsLike_allDijet_mass1 == dFloat) {
              higgsLike_allDijet_mass1 = higgsLike_allDijet_mass2;
            }
          }
          if (pfjetsSelected.at(i).btagCombinedSecVertex <= btagThres
              && pfjetsSelected.at(j).btagCombinedSecVertex <= btagThres) {
            if (fabs(81 - wLike_allDijet_mass1) > fabs(81 - higgsLike_allDijet_mass2)
                || wLike_allDijet_mass1 == dFloat) {
              wLike_allDijet_mass1 = higgsLike_allDijet_mass2;
            }
          }
          for (int k=j+1; k < numGoodAndBadJets; k++) {
            sum_topLike_allTrijet_vect = allJetV[i] + allJetV[j] + allJetV[k];
            topLike_allTrijet_mass2 = sum_topLike_allTrijet_vect.M();
            if ( ( 1*(pfjetsSelected.at(i).btagCombinedSecVertex > btagThres)
                   + 1*(pfjetsSelected.at(j).btagCombinedSecVertex > btagThres)
                   + 1*(pfjetsSelected.at(k).btagCombinedSecVertex > btagThres) ) == 1) {
              if (fabs(160 - topLike_allTrijet_mass1) > fabs(160 - topLike_allTrijet_mass2)
                  || topLike_allTrijet_mass1 == dFloat) {
                topLike_allTrijet_mass1 = topLike_allTrijet_mass2;
              }
            }
          }
          
        }

      }

      if (debug_) std::cout << "Beginning loop over jets" << std::endl;

      TLorentzVector sum_topLike_dijet_lep1_vect;
      TLorentzVector sum_topLike_dijet_lep2_vect;
      bool first_bjet_found = false;
      int numNonbjetsDom = 0 ;

      if (debug_) std::cout << "first_CSV_index = " << first_CSV_index << " , CSV = " << jet_CSV[first_CSV_index] << std::endl;
      if (debug_) std::cout << "second_CSV_index = " << second_CSV_index << " , CSV = " << jet_CSV[second_CSV_index] << std::endl;
	  for (int i=0; i < numGoodJets; i++) {
        if (debug_) std::cout << "jet_index[" << i << "] = " << jet_index[i] << " , CSV = " << jet_CSV[jet_index[i]] << std::endl;
	    int iJet = jet_index[i] ;
        if (sum_jet_pt == dFloat) sum_jet_pt = 0.0;
        if (sum_jet_CHEF == dFloat) sum_jet_CHEF = 0.0;
        if (sum_jet_charge == dFloat) sum_jet_charge = 0.0;
        if (sum_untagged_jet_charge == dFloat) sum_untagged_jet_charge = 0.0;
        if (sum_tagged_jet_charge == dFloat) sum_tagged_jet_charge = 0.0;

	    sum_pt += jet_pt[iJet];
        sum_jet_pt += jet_pt[iJet];
	    Ht += jet_energy[iJet];
        sum_jet_CHEF += jet_CHEF[iJet];
        sum_jet_charge += jet_charge[iJet];
        if (jet_CSV[iJet] > btagThres) sum_tagged_jet_charge += jet_charge[iJet];
        else sum_untagged_jet_charge += jet_charge[iJet];

        
	    jet_vect.SetPxPyPzE(jet_px[iJet],jet_py[iJet],jet_pz[iJet],jet_energy[iJet]);
        jet_vect_transverse.SetPxPyPzE(jet_px[iJet],jet_py[iJet],0.0,jet_pt[iJet]);
        
        for (int j=i+1; j < numGoodJets; j++) {
          sum_higgsLike_dijet_vect = jetV[i] + jetV[j];
          higgsLike_dijet_massX = sum_higgsLike_dijet_vect.M();
          higgsLike_dijet_ptX = sum_higgsLike_dijet_vect.Pt();
          higgsLike_dijet_etaX = sum_higgsLike_dijet_vect.Eta();
          sum_topLike_dijet_lep1_vect = jetV[i] + jetV[j] + lep_vect1;
          sum_topLike_dijet_lep2_vect = jetV[i] + jetV[j] + lep_vect2;
          if (pfjetsSelected.at(iJet).btagCombinedSecVertex > btagThres
              || pfjetsSelected.at(jet_index[j]).btagCombinedSecVertex > btagThres) {
            if (fabs(higgs_mass - higgsLike_dijet_mass2) > fabs(higgs_mass - higgsLike_dijet_massX)
                || higgsLike_dijet_mass2 == dFloat) {
              if (fabs(higgs_mass - higgsLike_dijet_mass1) > fabs(higgs_mass - higgsLike_dijet_massX)
                  || higgsLike_dijet_mass1 == dFloat) higgsLike_dijet_mass2 = higgsLike_dijet_mass1;
              else higgsLike_dijet_mass2 = higgsLike_dijet_massX;
            }
            if (fabs(higgs_mass - higgsLike_dijet_mass1) > fabs(higgs_mass - higgsLike_dijet_massX)
                || higgsLike_dijet_mass1 == dFloat) {
              higgsLike_dijet_mass1 = higgsLike_dijet_massX;
              higgsLike_dijet_dR = jetV[i].DeltaR(jetV[j]);
              higgsLike_dijet_pt = sum_higgsLike_dijet_vect.Pt();
              higgsLike_dijet_eta = sum_higgsLike_dijet_vect.Eta();
              higgsLike_dijet_jet1_pt = max(jetV[i].Pt(),jetV[j].Pt());
              higgsLike_dijet_jet2_pt = min(jetV[i].Pt(),jetV[j].Pt());
            }
            if (fabs(higgs_mass - higgsLike_dijet_massX) < 10) numHiggsLike_dijet_10++;
            if (fabs(higgs_mass - higgsLike_dijet_massX) < 15) numHiggsLike_dijet_15++;
            if (fabs(higgs_mass - higgsLike_dijet_massX) < 20) numHiggsLike_dijet_20++;
            if (fabs(higgs_mass - higgsLike_dijet_massX) < 25) numHiggsLike_dijet_25++;
            if (pfjetsSelected.at(iJet).btagCombinedSecVertex > btagThres
                && pfjetsSelected.at(jet_index[j]).btagCombinedSecVertex > btagThres) {
              if (fabs(higgs_mass - higgsLike_diBjet_mass1) > fabs(higgs_mass - higgsLike_dijet_massX)
                  || higgsLike_diBjet_mass1 == dFloat)  higgsLike_diBjet_mass1 = higgsLike_dijet_massX;
              if (fabs(higgs_mass - higgsLike_dijet_massX) < 10) numHiggsLike_diBjet_10++;
              if (fabs(higgs_mass - higgsLike_dijet_massX) < 15) numHiggsLike_diBjet_15++;
              if (fabs(higgs_mass - higgsLike_dijet_massX) < 20) numHiggsLike_diBjet_20++;
              if (fabs(higgs_mass - higgsLike_dijet_massX) < 25) numHiggsLike_diBjet_25++;
            }
          }

          if (jet_index[i] != first_CSV_index && jet_index[j] != first_CSV_index) {
            if (fabs(81 - wLike_dijet_mass_low1CSV1) > fabs(81 - higgsLike_dijet_massX) || wLike_dijet_mass_low1CSV1 == dFloat) {
              wLike_dijet_mass_low1CSV1 = higgsLike_dijet_massX;
              wLike_dijet_pt_low1CSV = higgsLike_dijet_ptX;
              wLike_dijet_eta_low1CSV = higgsLike_dijet_etaX;
              topLike_dijet_lep1_mass_low1CSV = sum_topLike_dijet_lep1_vect.M();
              topLike_dijet_lep2_mass_low1CSV = sum_topLike_dijet_lep2_vect.M();
            }
          }
          if (jet_index[i] != first_CSV_index && jet_index[i] != second_CSV_index
              && jet_index[j] != first_CSV_index && jet_index[j] != second_CSV_index) {
            if (fabs(81 - wLike_dijet_mass_low2CSV1) > fabs(81 - higgsLike_dijet_massX) || wLike_dijet_mass_low2CSV1 == dFloat) {
              wLike_dijet_mass_low2CSV1 = higgsLike_dijet_massX;
              wLike_dijet_pt_low2CSV = higgsLike_dijet_ptX;
              wLike_dijet_eta_low2CSV = higgsLike_dijet_etaX;
              topLike_dijet_lep1_mass_low2CSV = sum_topLike_dijet_lep1_vect.M();
              topLike_dijet_lep2_mass_low2CSV = sum_topLike_dijet_lep2_vect.M();
            }
          }

          int k_min = 100;
          for (int k=0; k < numGoodJets; k++) {
            if (k != i && k != j) {
              if (k < k_min) k_min = k;
              sum_topLike_trijet_vect = jetV[i] + jetV[j] + jetV[k];

              if (wLike_dijet_mass_low1CSV1 == higgsLike_dijet_massX) {
                topLike_trijet_mass_hiCSV_low1CSV2 = sum_topLike_trijet_vect.M();
                if (jet_index[k] == first_CSV_index) {
                  if (fabs(160 - topLike_trijet_mass_hiCSV_low1CSV1) > fabs(160 - topLike_trijet_mass_hiCSV_low1CSV2) || topLike_trijet_mass_hiCSV_low1CSV1 == dFloat || k == k_min) {
                    topLike_trijet_mass_hiCSV_low1CSV1 = topLike_trijet_mass_hiCSV_low1CSV2;
                  }
                }
              }
              if (wLike_dijet_mass_low1CSV1 == higgsLike_dijet_massX) {
                topLike_trijet_mass_medTag_low1CSV2 = sum_topLike_trijet_vect.M();
                if (pfjetsSelected.at(jet_index[k]).btagCombinedSecVertex > btagThres) {
                  if (fabs(160 - topLike_trijet_mass_medTag_low1CSV1) > fabs(160 - topLike_trijet_mass_medTag_low1CSV2) || topLike_trijet_mass_medTag_low1CSV1 == dFloat || k == k_min) {
                    topLike_trijet_mass_medTag_low1CSV1 = topLike_trijet_mass_medTag_low1CSV2;
                  }
                }
              }
              if (wLike_dijet_mass_low1CSV1 == higgsLike_dijet_massX) {
                topLike_trijet_mass_looseTag_low1CSV2 = sum_topLike_trijet_vect.M();
                if (pfjetsSelected.at(jet_index[k]).btagCombinedSecVertex > btagThresLoose) {
                  if (fabs(160 - topLike_trijet_mass_looseTag_low1CSV1) > fabs(160 - topLike_trijet_mass_looseTag_low1CSV2) || topLike_trijet_mass_looseTag_low1CSV1 == dFloat || k == k_min) {
                    topLike_trijet_mass_looseTag_low1CSV1 = topLike_trijet_mass_looseTag_low1CSV2;
                  }
                }
              }
              
              if (wLike_dijet_mass_low2CSV1 == higgsLike_dijet_massX) {
                topLike_trijet_mass_hiCSV_low2CSV2 = sum_topLike_trijet_vect.M();
                if (jet_index[k] == first_CSV_index) {
                  if (fabs(160 - topLike_trijet_mass_hiCSV_low2CSV1) > fabs(160 - topLike_trijet_mass_hiCSV_low2CSV2) || topLike_trijet_mass_hiCSV_low2CSV1 == dFloat || k == k_min) {
                    topLike_trijet_mass_hiCSV_low2CSV1 = topLike_trijet_mass_hiCSV_low2CSV2;
                  }
                }
              }
              if (wLike_dijet_mass_low2CSV1 == higgsLike_dijet_massX) {
                topLike_trijet_mass_medTag_low2CSV2 = sum_topLike_trijet_vect.M();
                if (pfjetsSelected.at(jet_index[k]).btagCombinedSecVertex > btagThres) {
                  if (fabs(160 - topLike_trijet_mass_medTag_low2CSV1) > fabs(160 - topLike_trijet_mass_medTag_low2CSV2) || topLike_trijet_mass_medTag_low2CSV1 == dFloat || k == k_min) {
                    topLike_trijet_mass_medTag_low2CSV1 = topLike_trijet_mass_medTag_low2CSV2;
                  }
                }
              }
              if (wLike_dijet_mass_low2CSV1 == higgsLike_dijet_massX) {
                topLike_trijet_mass_looseTag_low2CSV2 = sum_topLike_trijet_vect.M();
                if (pfjetsSelected.at(jet_index[k]).btagCombinedSecVertex > btagThresLoose) {
                  if (fabs(160 - topLike_trijet_mass_looseTag_low2CSV1) > fabs(160 - topLike_trijet_mass_looseTag_low2CSV2) || topLike_trijet_mass_looseTag_low2CSV1 == dFloat || k == k_min) {
                    topLike_trijet_mass_looseTag_low2CSV1 = topLike_trijet_mass_looseTag_low2CSV2;
                  }
                }
              }
            
            } //End if k != j or i
          } //End k loop over numGoodJets
        } //End j loop over numGoodJets

        if (first_lf_jet_pt == dFloat && pfjetsSelected.at(iJet).flavour > 0 && pfjetsSelected.at(iJet).flavour < 4) {
          first_lf_jet_pt = jet_pt[iJet];
          first_lf_jet_eta = jet_vect.Eta();
          first_lf_jet_CSV_unshaped = pfjetsSelected_Uncorrected.at(iJet).btagCombinedSecVertex;
          first_lf_jet_CSV_reshaped = pfjetsSelected.at(iJet).btagCombinedSecVertex;
        }
        if (first_hf_jet_pt == dFloat && pfjetsSelected.at(iJet).flavour > 3 && pfjetsSelected.at(iJet).flavour < 6) {
          first_hf_jet_pt = jet_pt[iJet];
          first_hf_jet_eta = jet_vect.Eta();
          first_hf_jet_CSV_unshaped = pfjetsSelected_Uncorrected.at(iJet).btagCombinedSecVertex;
          first_hf_jet_CSV_reshaped = pfjetsSelected.at(iJet).btagCombinedSecVertex;
        }

        ////
        if (pfjetsSelected.at(iJet).btagCombinedSecVertex > btagThres && ! first_bjet_found) {
          first_bjet_pt = jet_pt[iJet];
          first_bjet_found = true;
        }

        if (jet_index[i]==first_CSV_index) { //Highest CSV jet

          bjet1_vect = jet_vect;

          MHT_lep1_b1_vect = MHT_lep1_vect + jet_vect_transverse;
          MHT_lep2_b1_vect = MHT_lep2_vect + jet_vect_transverse;
          met_lep1_b1_vect = met_lep1_vect + jet_vect_transverse;
          met_lep2_b1_vect = met_lep2_vect + jet_vect_transverse;
          lep1_b1_vect = lep_vect1 + jet_vect;
          lep2_b1_vect = lep_vect2 + jet_vect;

          MT_MHT_lep1_b1 = MHT_lep1_b1_vect.M();
          MT_MHT_lep2_b1 = MHT_lep2_b1_vect.M();
          MT_met_lep1_b1 = met_lep1_b1_vect.M();
          MT_met_lep2_b1 = met_lep2_b1_vect.M();
          mass_lep1_b1 = lep1_b1_vect.M();
          mass_lep2_b1 = lep2_b1_vect.M();
          dR_lep1_b1 = lep_vect1.DeltaR(jet_vect);
          dR_lep2_b1 = lep_vect2.DeltaR(jet_vect);

          b1_jet_pt = jet_vect.Pt();
          b1_jet_eta = jet_vect.Eta();
          b1_jet_CSV = jet_CSV[iJet];
        }
        if (jet_index[i]==second_CSV_index) { //Highest CSV jet

          bjet2_vect = jet_vect;

          MHT_lep1_b2_vect = MHT_lep1_vect + jet_vect_transverse;
          MHT_lep2_b2_vect = MHT_lep2_vect + jet_vect_transverse;
          met_lep1_b2_vect = met_lep1_vect + jet_vect_transverse;
          met_lep2_b2_vect = met_lep2_vect + jet_vect_transverse;
          lep1_b2_vect = lep_vect1 + jet_vect;
          lep2_b2_vect = lep_vect2 + jet_vect;

          MT_MHT_lep1_b2 = MHT_lep1_b2_vect.M();
          MT_MHT_lep2_b2 = MHT_lep2_b2_vect.M();
          MT_met_lep1_b2 = met_lep1_b2_vect.M();
          MT_met_lep2_b2 = met_lep2_b2_vect.M();
          mass_lep1_b2 = lep1_b2_vect.M();
          mass_lep2_b2 = lep2_b2_vect.M();
          dR_lep1_b2 = lep_vect1.DeltaR(jet_vect);
          dR_lep2_b2 = lep_vect2.DeltaR(jet_vect);

          b2_jet_pt = jet_vect.Pt();
          b2_jet_eta = jet_vect.Eta();
          b2_jet_CSV = jet_CSV[iJet];
        }

        
        
	    if (i==0)  {        
          first_jet_pt = jet_pt[iJet];
          first_jet_eta = jet_vect.Eta();
          first_jet_CHEF = jet_CHEF[iJet];
          first_jet_charge = jet_charge[iJet];
          first_jet_CSV = pfjetsSelected.at(iJet).btagCombinedSecVertex;
          first_jet_CSV_unc = pfjetsSelected_Uncorrected.at(iJet).btagCombinedSecVertex;
          first_jet_genID = pfjetsSelected.at(iJet).genPartonId;
          first_jet_flavor = pfjetsSelected.at(iJet).flavour;
	  //	  if(first_jet_genID!=first_jet_flavor) cout << "genID and flavor dont match: genID:flavor "<< first_jet_genID << ":" << first_jet_flavor  << endl;
          if (first_jet_pt > 30 && first_jet_pt < 45) {
            if (fabs(first_jet_eta) > 0 && fabs(first_jet_eta) < 1.2 ) CSV_30to45_0p0to1p2_1 = first_jet_CSV;
            if (fabs(first_jet_eta) > 1.2 && fabs(first_jet_eta) < 2.1 ) CSV_30to45_1p2to2p1_1 = first_jet_CSV;
            if (fabs(first_jet_eta) > 2.1 && fabs(first_jet_eta) < 2.4 ) CSV_30to45_2p1to2p4_1 = first_jet_CSV;
          }
          if (first_jet_pt > 45 && first_jet_pt < 75) {
            if (fabs(first_jet_eta) > 0 && fabs(first_jet_eta) < 1.2 ) CSV_45to75_0p0to1p2_1 = first_jet_CSV;
            if (fabs(first_jet_eta) > 1.2 && fabs(first_jet_eta) < 2.1 ) CSV_45to75_1p2to2p1_1 = first_jet_CSV;
            if (fabs(first_jet_eta) > 2.1 && fabs(first_jet_eta) < 2.4 ) CSV_45to75_2p1to2p4_1 = first_jet_CSV;
          }
          if (first_jet_pt > 75 && first_jet_pt < 150) {
            if (fabs(first_jet_eta) > 0 && fabs(first_jet_eta) < 1.2 ) CSV_75to150_0p0to1p2_1 = first_jet_CSV;
            if (fabs(first_jet_eta) > 1.2 && fabs(first_jet_eta) < 2.1 ) CSV_75to150_1p2to2p1_1 = first_jet_CSV;
            if (fabs(first_jet_eta) > 2.1 && fabs(first_jet_eta) < 2.4 ) CSV_75to150_2p1to2p4_1 = first_jet_CSV;
          }
          if (first_jet_pt > 150) {
            if (fabs(first_jet_eta) > 0 && fabs(first_jet_eta) < 1.2 ) CSV_150toInf_0p0to1p2_1 = first_jet_CSV;
            if (fabs(first_jet_eta) > 1.2 && fabs(first_jet_eta) < 2.1 ) CSV_150toInf_1p2to2p1_1 = first_jet_CSV;
            if (fabs(first_jet_eta) > 2.1 && fabs(first_jet_eta) < 2.4 ) CSV_150toInf_2p1to2p4_1 = first_jet_CSV;
          }
        }
	    if (i==1)  {
          second_jet_pt = jet_pt[iJet];
          second_jet_eta = jet_vect.Eta();
          second_jet_CHEF = jet_CHEF[iJet];
          second_jet_charge = jet_charge[iJet];
          second_jet_CSV = pfjetsSelected.at(iJet).btagCombinedSecVertex;
          second_jet_CSV_unc = pfjetsSelected_Uncorrected.at(iJet).btagCombinedSecVertex;
          second_jet_genID = pfjetsSelected.at(iJet).genPartonId;
          second_jet_flavor = pfjetsSelected.at(iJet).flavour;
          if (second_jet_pt > 30 && second_jet_pt < 45) {
            if (fabs(second_jet_eta) > 0 && fabs(second_jet_eta) < 1.2 ) CSV_30to45_0p0to1p2_2 = second_jet_CSV;
            if (fabs(second_jet_eta) > 1.2 && fabs(second_jet_eta) < 2.1 ) CSV_30to45_1p2to2p1_2 = second_jet_CSV;
            if (fabs(second_jet_eta) > 2.1 && fabs(second_jet_eta) < 2.4 ) CSV_30to45_2p1to2p4_2 = second_jet_CSV;
          }
          if (second_jet_pt > 45 && second_jet_pt < 75) {
            if (fabs(second_jet_eta) > 0 && fabs(second_jet_eta) < 1.2 ) CSV_45to75_0p0to1p2_2 = second_jet_CSV;
            if (fabs(second_jet_eta) > 1.2 && fabs(second_jet_eta) < 2.1 ) CSV_45to75_1p2to2p1_2 = second_jet_CSV;
            if (fabs(second_jet_eta) > 2.1 && fabs(second_jet_eta) < 2.4 ) CSV_45to75_2p1to2p4_2 = second_jet_CSV;
          }
          if (second_jet_pt > 75 && second_jet_pt < 150) {
            if (fabs(second_jet_eta) > 0 && fabs(second_jet_eta) < 1.2 ) CSV_75to150_0p0to1p2_2 = second_jet_CSV;
            if (fabs(second_jet_eta) > 1.2 && fabs(second_jet_eta) < 2.1 ) CSV_75to150_1p2to2p1_2 = second_jet_CSV;
            if (fabs(second_jet_eta) > 2.1 && fabs(second_jet_eta) < 2.4 ) CSV_75to150_2p1to2p4_2 = second_jet_CSV;
          }
          if (second_jet_pt > 150) {
            if (fabs(second_jet_eta) > 0 && fabs(second_jet_eta) < 1.2 ) CSV_150toInf_0p0to1p2_2 = second_jet_CSV;
            if (fabs(second_jet_eta) > 1.2 && fabs(second_jet_eta) < 2.1 ) CSV_150toInf_1p2to2p1_2 = second_jet_CSV;
            if (fabs(second_jet_eta) > 2.1 && fabs(second_jet_eta) < 2.4 ) CSV_150toInf_2p1to2p4_2 = second_jet_CSV;
          }
        }
	    if (i==2)  {
          third_jet_pt = jet_pt[iJet];
          third_jet_eta = jet_vect.Eta();
          third_jet_CHEF = jet_CHEF[iJet];
          third_jet_charge = jet_charge[iJet];
          third_jet_CSV = pfjetsSelected.at(iJet).btagCombinedSecVertex;
          third_jet_CSV_unc = pfjetsSelected_Uncorrected.at(iJet).btagCombinedSecVertex;
          third_jet_genID = pfjetsSelected.at(iJet).genPartonId;
	  third_jet_flavor = pfjetsSelected.at(iJet).flavour;
        }
	    if (i==3)  {
          fourth_jet_pt = jet_pt[iJet];
          fourth_jet_eta = jet_vect.Eta();
          fourth_jet_CHEF = jet_CHEF[iJet];
          fourth_jet_charge = jet_charge[iJet];
          fourth_jet_CSV = pfjetsSelected.at(iJet).btagCombinedSecVertex;
          fourth_jet_CSV_unc = pfjetsSelected_Uncorrected.at(iJet).btagCombinedSecVertex;
          fourth_jet_genID = pfjetsSelected.at(iJet).genPartonId;
	  fourth_jet_flavor = pfjetsSelected.at(iJet).flavour;
        }
	    
	    if (mindr_lep1_jet > lep_vect1.DeltaR(jet_vect) || mindr_lep1_jet == dFloat){
	      mindr_lep1_jet = lep_vect1.DeltaR(jet_vect);
          ptRel_lep1_jet = lep_vect1.Pt() / (lep_vect1.Pt() + jet_vect.Pt());
	    }
	    
	    if (mindr_lep2_jet > lep_vect2.DeltaR(jet_vect) || mindr_lep2_jet == dFloat){
	      mindr_lep2_jet = lep_vect2.DeltaR(jet_vect); 
          ptRel_lep2_jet = lep_vect2.Pt() / (lep_vect2.Pt() + jet_vect.Pt());
	    }
	    
	    if (jet_CSV[i] > btagThres){
          if (avg_btag_disc_btags == dFloat) avg_btag_disc_btags = 0.0;
	      avg_btag_disc_btags += jet_CSV[i];
	    }
	    
	    if (jet_CSV[i] <= btagThres){
	      if (avg_btag_disc_non_btags == dFloat) avg_btag_disc_non_btags = 0.0;
	      if (jet_CSV[i] > 0){
		avg_btag_disc_non_btags += jet_CSV[i];
		numNonbjetsDom++;
	      }
	      highest_btag_disc_non_btags = max(highest_btag_disc_non_btags,jet_CSV[i]);
	    }									
	  } // End of loop over numGoodJets

      ttbar_vect = metV + lep_vect1 + lep_vect2 + bjet1_vect + bjet2_vect;
      pt_of_ttbar = ttbar_vect.Pt();
      
	  if ( numTaggedJets > 0 ) avg_btag_disc_btags /= numTaggedJets;
	  
	  if ((numGoodJets - numTaggedJets) != 0){
	    if (numNonbjetsDom == 0) avg_btag_disc_non_btags = -1; 
	    else avg_btag_disc_non_btags /= numNonbjetsDom;
	  }
	  
	  for (int l=0; l < numTaggedJets; l++){
        if (dev_from_avg_disc_btags == dFloat) dev_from_avg_disc_btags = 0.0;
        dev_from_avg_disc_btags += pow((tagJet_CSV[l] - avg_btag_disc_btags),2);
	  }
	  if ( numTaggedJets > 0 ) dev_from_avg_disc_btags /= numTaggedJets;

	  /////
	  all_sum_pt = sum_pt + MHT;
	  Ht += MHT;

      /// Ht re-weighting
//       float HtWgt = dFloat;
//       float HtWgtUp = dFloat;
//       ////////////// mistake  for 2011
//       if (!isData){
//         if (sum_jet_pt == dFloat) sum_jet_pt = 0.0;
//         if(selectionYearStr == "2012_52x" || selectionYearStr == "2012_53x"){
//           if (numPV<11)  HtWgt = h_rwt_lowPV->GetBinContent(h_rwt_lowPV->FindBin(sum_jet_pt));
//           else if (10<numPV && numPV<16)  HtWgt = h_rwt_medPV->GetBinContent(h_rwt_medPV->FindBin(sum_jet_pt));
//           else   HtWgt = h_rwt_highPV->GetBinContent(h_rwt_highPV->FindBin(sum_jet_pt));
//         }
//         else if(selectionYearStr == "2011") {  /// 2011
//           if (numPV<6)  HtWgt = h_rwt_lowPV->GetBinContent(h_rwt_lowPV->FindBin(sum_jet_pt));
//           else if (5<numPV && numPV<9)  HtWgt = h_rwt_medPV->GetBinContent(h_rwt_medPV->FindBin(sum_jet_pt));
//           else   HtWgt = h_rwt_highPV->GetBinContent(h_rwt_highPV->FindBin(sum_jet_pt));
//         }
//         else {
//           assert (selectionYearStr == "either 2012_52x, 2012_53x, or 2011");
//         }
        
//         HtWgtUp = 1 + 2*(HtWgt - 1);
//         if (sum_jet_pt == 0.0) sum_jet_pt = dFloat;
//       }

      bool PassBigDiamondZmask = (MuonEle || (mass_leplep < (65.5 + 3*MHT/8)) || (mass_leplep > (108 - MHT/4)) || (mass_leplep < (79 - 3*MHT/4)) || (mass_leplep > (99 + MHT/2)) );
      bool PassBigDiamondZmask2 = (mass_leplep < (65.5 + 3*met/8)) || (mass_leplep > (108 - met/4)) || (mass_leplep < (79 - 3*met/4)) || (mass_leplep > (99 + met/2));
      bool PassBigDiamondZmask3 = (mass_leplep < (65.5 + 3*pt_of_leps_and_allJets/8)) || (mass_leplep > (108 - pt_of_leps_and_allJets/4)) || (pt_of_leps_and_allJets < (79 - 3*pt_of_leps_and_allJets/4)) || (mass_leplep > (99 + pt_of_leps_and_allJets/2));


      if (debug_) std::cout << "Beginning loop over tagged jets" << std::endl;      
	  //// tagged jets
	  float deltaHMass = 9999. ;
	  float deltaHMass2 = 9999. ;
      denom_avg_cnt = 0.0;
	  if (numTaggedJets > 1) {
	    for (int j=0; j < (numTaggedJets - 1); j++) {
	      int jbtag = tagJet_index[j] ;
	      btag_vect1.SetPxPyPzE(jet_px[jbtag],jet_py[jbtag],jet_pz[jbtag],jet_energy[jbtag]);
	      
	      for (int k=j+1; k < numTaggedJets; k++) {
		int kbtag = tagJet_index[k] ; 
		btag_vect2.SetPxPyPzE(jet_px[kbtag],jet_py[kbtag],jet_pz[kbtag],jet_energy[kbtag]);
		
		dijet_vect = btag_vect1 + btag_vect2;
        if (avg_tagged_dijet_mass == dFloat) avg_tagged_dijet_mass = 0.0;
		avg_tagged_dijet_mass += dijet_vect.M();
        if (avg_dr_tagged_jets == dFloat) avg_dr_tagged_jets = 0.0;
		avg_dr_tagged_jets += btag_vect1.DeltaR(btag_vect2);
		++denom_avg_cnt;		      
		
		if (min_dr_tagged_jets > btag_vect1.DeltaR(btag_vect2) || min_dr_tagged_jets == dFloat){
		  min_dr_tagged_jets = btag_vect1.DeltaR(btag_vect2);
		  M2_of_closest_tagged_jets = dijet_vect.M2();	
		  closest_tagged_dijet_mass = dijet_vect.M();			
		}

		//////// ttbb bkg
		dibjet_mass_combinations.push_back(dijet_vect.M()); 
		float deltaHMassTemp = abs(higgs_mass - dijet_vect.M());
		if (deltaHMassTemp < deltaHMass) {
		  deltaHMass = deltaHMassTemp ;
		  m2H_btag = dijet_vect.M() ;
		}
		
	      } // End loop for k < numTaggedJets
	    } // End loop for j < numTaggedJets
	    
	    avg_tagged_dijet_mass /= denom_avg_cnt; 
	    avg_dr_tagged_jets /= denom_avg_cnt;
	    
	    ///// ttbb bkg
      if (debug_) std::cout << "Beginning second loop over jets" << std::endl;

	    dibjet_mass_combinations.sort();
	    std::vector<float> dibjet_mass_sort_vect;
	    std::list<float>::iterator listintaa;
	    for (listintaa = dibjet_mass_combinations.begin(); listintaa != dibjet_mass_combinations.end(); listintaa++){
	      dibjet_mass_sort_vect.push_back(*listintaa);  //accessible form
	    }
	    int numCom = dibjet_mass_sort_vect.size();
        if (numCom > 0) first_dibjet_mass  = dibjet_mass_sort_vect[numCom - 1];
        if (numCom > 1) second_dibjet_mass = dibjet_mass_sort_vect[numCom - 2];
        if (numCom > 2) third_dibjet_mass  = dibjet_mass_sort_vect[numCom - 3];
        lowest_dibjet_mass = dibjet_mass_sort_vect[0];
	  } // End if numTaggedJets > 1

	  
	  ////non_tagged jets
      if (debug_) std::cout << "Beginning loop over untagged jets" << std::endl;	  
	  denom_avg_cnt = 0.0;
	  int nonTags = untagJet_index.size();
	  if (nonTags > 1){
	    for (int m=0; m < (nonTags - 1); m++){
	      int untag1 = untagJet_index[m];
	      non_btag_vect1.SetPxPyPzE(jet_px[untag1],jet_py[untag1],jet_pz[untag1],jet_energy[untag1]);
	      for (int n=m+1; n < nonTags; n++){
		int untag2 = untagJet_index[n];
		non_btag_vect2.SetPxPyPzE(jet_px[untag2],jet_py[untag2],jet_pz[untag2],jet_energy[untag2]);
		
		dijet_vect = non_btag_vect1 + non_btag_vect2;
        untagged_dijet_mass_combinations.push_back(dijet_vect.M());
        if (avg_untagged_dijet_mass == dFloat) avg_untagged_dijet_mass = 0.0;
		avg_untagged_dijet_mass += dijet_vect.M();
		++denom_avg_cnt;
	      }
	    }
        
        untagged_dijet_mass_combinations.sort();
        std::vector<float> untagged_dijet_mass_sort_vect;
        std::list<float>::iterator listinLF;
        for (listinLF = untagged_dijet_mass_combinations.begin(); listinLF != untagged_dijet_mass_combinations.end(); listinLF++){
          untagged_dijet_mass_sort_vect.push_back(*listinLF);  //accessible form
        }
        int numCom = untagged_dijet_mass_sort_vect.size();
        if (numCom > 0) first_untagged_dijet_mass  = untagged_dijet_mass_sort_vect[numCom - 1];
        if (numCom > 1) second_untagged_dijet_mass = untagged_dijet_mass_sort_vect[numCom - 2];
        if (numCom > 2) third_untagged_dijet_mass  = untagged_dijet_mass_sort_vect[numCom - 3];
        if (numCom > 0) lowest_untagged_dijet_mass  = untagged_dijet_mass_sort_vect[0];
        
	    avg_untagged_dijet_mass /= denom_avg_cnt;
	  } // End if nonTags > 1

      if (debug_) std::cout << "Beginning another loop over jets" << std::endl;	  
	  
	  ///// ttbb dijet_mass
	  denom_avg_cnt = 0.0;
	  if(numJets > 1 ) {
	    for (int j=0; j < (numJets - 1); j++) {
	      int jJet = jet_index[j] ;
	      jet_vect1.SetPxPyPzE(jet_px[jJet],jet_py[jJet],jet_pz[jJet],jet_energy[jJet]);
	      
	      for (int k=j+1; k < numJets; k++) {
		int kJet = jet_index[k] ; 
		jet_vect2.SetPxPyPzE(jet_px[kJet],jet_py[kJet],jet_pz[kJet],jet_energy[kJet]);
		
		dijet_vect = jet_vect1 + jet_vect2;
        if (avg_dijet_mass == dFloat) avg_dijet_mass = 0.0;
		avg_dijet_mass += dijet_vect.M();
        if (avg_dr_jets == dFloat) avg_dr_jets = 0.0;
		avg_dr_jets += jet_vect1.DeltaR(jet_vect2);
		++denom_avg_cnt;		      
		
		if (min_dr_jets > jet_vect1.DeltaR(jet_vect2) || min_dr_jets == dFloat){
		  min_dr_jets = jet_vect1.DeltaR(jet_vect2);
		  M2_of_closest_jets = dijet_vect.M2();	
		  closest_dijet_mass = dijet_vect.M();			
		}

		//////// ttbb bkg
		dijet_mass_combinations.push_back(dijet_vect.M()); 
		float deltaHMassTemp2 = abs(higgs_mass - dijet_vect.M());
		if (deltaHMassTemp2 < deltaHMass2) {
		  deltaHMass2 = deltaHMassTemp2 ;
		  dijet_mass_m2H = dijet_vect.M() ;
		}
		
	      } //end loop over k
	    } //end loop over j

	    avg_dijet_mass /= denom_avg_cnt; 
	    avg_dr_jets /= denom_avg_cnt;
	    
	    dijet_mass_combinations.sort();
	    std::vector<float> dijet_mass_sort_vect; 
	    std::list<float>::iterator listintbb;
	    for (listintbb = dijet_mass_combinations.begin(); listintbb != dijet_mass_combinations.end(); listintbb++){
	      dijet_mass_sort_vect.push_back(*listintbb);  //accessible form
	    }
	    int numCom = dijet_mass_sort_vect.size();
        if (numCom > 0) dijet_mass_first  = dijet_mass_sort_vect[numCom - 1];
	    if (numCom > 1) dijet_mass_second = dijet_mass_sort_vect[numCom - 2];
        if (numCom > 2) dijet_mass_third  = dijet_mass_sort_vect[numCom - 3];
	    if (numCom > 0) dijet_mass_lowest = dijet_mass_sort_vect[0];
	    

	  } //end if numJets > 1

	  ////
      
	  
	  if (numTaggedJets > 0 ){
	    first_highest_btag = jet_CSV_sorted[numTaggedJets - 1];
	    if (numTaggedJets > 1) second_highest_btag = jet_CSV_sorted[numTaggedJets - 2];
	    lowest_btag = jet_CSV_sorted[0];	    
	  }

      //------------------------------------------
      //
      // Assign values to the vars the MVA will use
      // 
      //------------------------------------------
      if (debug_) std::cout << "Starting MVA" << std::endl;	  

      //Robin's variables
      varavg_btag_disc_non_btags = avg_btag_disc_non_btags;
      vardijet_mass_first = dijet_mass_first;
      vardijet_mass_third = dijet_mass_third;
      varavg_dijet_mass = avg_dijet_mass;
      vardijet_mass_m2H = dijet_mass_m2H;
      varfirst_jet_pt = first_jet_pt;
      
      //Opposite sign variables
      varavg_btag_disc_btags = avg_btag_disc_btags;
      varavg_dr_jets = avg_dr_jets;
      varmin_dr_jets = min_dr_jets;
      varHt = Ht;
      varhiggsLike_dijet_mass = higgsLike_dijet_mass1;
      varhiggsLike_dijet_mass2 = higgsLike_dijet_mass2;
      varmin_dr_tagged_jets = min_dr_tagged_jets; 
      varnumHiggsLike_dijet_15_float = float(numHiggsLike_dijet_15);
      varnumJets_float = float(numJets); 
      varmindr_lep1_jet = mindr_lep1_jet; 
      varsum_jet_pt = sum_jet_pt;
      varsum_pt = sum_pt;
      varall_sum_pt = all_sum_pt;    

      //Same sign vs. ttbar variables
      varcorrectedD0_leplep = correctedD0_leplep;
      varlep2Pt = lep2Pt;
      varmaxLepChargedIso = max(lep1ChargedIso,lep2ChargedIso);
      varMHT = MHT;
      varmaxLepAbsEta = max(abs(lep1Eta),abs(lep2Eta));
      varmindr_lep2_allJet = mindr_lep2_allJet;
      varmindr_lep2_jet = mindr_lep2_jet;
      //                    varnumJets_float;


      //Same sign vs. ttW variables
      //                    varlep2Pt;
      //      varmindr_lep1_allJet = mindr_lep1_allJet;
      //                    varmindr_lep1_jet;
      //                    varmindr_lep2_jet;
      //                    varnumJets_float;
      //                    varsum_jet_pt;
      
      //      std::cout << "-->error0 " << std::endl;
      for( unsigned int j = 0 ; j < nCat ; ++j ) {
        // --- Return the MVA outputs and weights
        TMVA::Reader  *tmpReader = reader[j];  
        TString branchName = TString("CFMlpANN_") + catList[j];
        //        cout << "This is NN category " << catList[j] << " saving into branch " << branchName << endl;
        Float_t annOut  = tmpReader->EvaluateMVA( "CFMlpANN method" );
        *(floatBranches[branchName]) = annOut;  

      } // End category loop

      if (debug_) std::cout << "About to fill branches" << std::endl;	  
      
      if (CoreVariables) {

        //event variables
        *(intBranches["PassTwoLepton"]) =  PassTwoLepton ? 1 : 0;
        *(intBranches["TwoMuon"]) = TwoMuon ? 1 : 0;
        *(intBranches["TwoEle"]) =  TwoEle ? 1 : 0;
        *(intBranches["MuonEle"]) = MuonEle ? 1 : 0;

        *(intBranches["numMuons"]) = numMuons;
        *(intBranches["numTightMuons"]) = numTightMuons;
        *(intBranches["numLooseMuons"]) = numLooseMuons;
        *(intBranches["numSideMuons"]) = numSideMuons;
        *(intBranches["numElectrons"]) = numElectrons;
        *(intBranches["numTightElectrons"]) = numTightElectrons;
        *(intBranches["numLooseElectrons"]) = numLooseElectrons;
        *(intBranches["numSideElectrons"]) = numSideElectrons;

        *(intBranches["numJets"]) = numJets ;
        *(intBranches["numTaggedJets"]) = numTaggedJets;
        *(intBranches["numLooseTaggedJets"]) = numLooseTaggedJets;
        *(floatBranches["numJets_float"]) = float(numJets);
        *(floatBranches["numTaggedJets_float"]) = float(numTaggedJets);
        *(floatBranches["numLooseTaggedJets_float"]) = float(numLooseTaggedJets);

        *(intBranches["isCleanEvent"]) = isCleanEvent ? 1 : 0;
        *(intBranches["isTriggerPass"]) = isTriggerPass ? 1 : 0;
        *(intBranches["isDoubleMuTriggerPass"]) = isDoubleMuTriggerPass ? 1 : 0;
        *(intBranches["isDoubleElectronTriggerPass"]) = isDoubleElectronTriggerPass ? 1 : 0;
        *(intBranches["isMuEGTriggerPass"]) = isMuEGTriggerPass ? 1 : 0;
        *(intBranches["isMETTriggerPass"]) = isMETTriggerPass ? 1 : 0;

        *(intBranches["PassZmask"]) = PassBigDiamondZmask ? 1 : 0;
        *(intBranches["PassZmask2"]) = PassBigDiamondZmask2 ? 1 : 0;

        *(intBranches["oppositeLepCharge"]) = oppositeLepCharge;
        *(intBranches["oppositeGenLepCharge"]) = oppositeGenLepCharge;
        
        *(uintBranches["runNumber"]) = event->run ;
        *(uintBranches["luminosityBlock"]) = event->lumi ;
        *(uintBranches["eventNumber"]) = unsigned(event->evt) ;
        *(intBranches["sampleNumber"]) = sampleNumber ;

        //pile up
        *(floatBranches["numPV"]) = numPV ;
        *(floatBranches["numTruePV"]) = numTruePV;
        *(floatBranches["numGenPV"]) = numGenPV;
        *(intBranches["numPartons"]) = numPartons;
        
        //weights
        *(floatBranches["weight"]) = weight ;
        *(floatBranches["weight_PUup"]) = weight_PUup ;
        *(floatBranches["weight_PUdown"]) = weight_PUdown ;
//         *(floatBranches["HtWgt"]) = HtWgt;
//         *(floatBranches["HtWgtUp"]) = HtWgtUp;
        *(floatBranches["Q2ScaleUpWgt"]) = Q2ScaleUpWgt;
        *(floatBranches["Q2ScaleDownWgt"]) = Q2ScaleDownWgt;
        *(floatBranches["lep1SF"]) = lep1SF;
        *(floatBranches["lep2SF"]) = lep2SF;
        *(floatBranches["lepTotalSF"]) = lepTotalSF;
        *(floatBranches["triggerSF"]) = triggerSF;

        //*(floatBranches["newSingleMuSF"]) = newSingleMuSF;
        //*(floatBranches["newSingleEleSF"]) = newSingleEleSF;
        //*(floatBranches["oldSingleMuSF"]) = oldSingleMuSF;
        //*(floatBranches["oldSingleEleSF"]) = oldSingleEleSF;

        *(floatBranches["weight_Xsec"]) = weight_Xsec ;
        *(floatBranches["nGen"]) = nGen ;
        *(floatBranches["Xsec"]) = Xsec ;
        *(floatBranches["topPtWgt"]) = topPtWgt ;
        *(floatBranches["topPtWgtUp"]) = topPtWgtUp ;
        *(floatBranches["csvWgtlf"]) = csvWgtlf[0] ;
        *(floatBranches["csvWgthf"]) = csvWgthf[0] ;
	//// extra btag SFs weights
	*(floatBranches["csvWgtlf_HFUp"])      = csvWgtlf[1];
	*(floatBranches["csvWgtlf_HFDown"])    = csvWgtlf[2];
	*(floatBranches["csvWgtlf_Stats1Up"])   = csvWgtlf[3];
	*(floatBranches["csvWgtlf_Stats1Down"]) = csvWgtlf[4];
	*(floatBranches["csvWgtlf_Stats2Up"])   = csvWgtlf[5];
	*(floatBranches["csvWgtlf_Stats2Down"]) = csvWgtlf[6];

	*(floatBranches["csvWgthf_LFUp"])      = csvWgthf[1];
	*(floatBranches["csvWgthf_LFDown"])    = csvWgthf[2];
	*(floatBranches["csvWgthf_Stats1Up"])   = csvWgthf[3];
	*(floatBranches["csvWgthf_Stats1Down"]) = csvWgthf[4];
	*(floatBranches["csvWgthf_Stats2Up"])   = csvWgthf[5];
	*(floatBranches["csvWgthf_Stats2Down"]) = csvWgthf[6];

        //met
        *(floatBranches["met"]) = met;
        *(floatBranches["unc_met"]) = unc_met;
        *(floatBranches["MHT"]) = MHT;

        //lepton variables
        *(floatBranches["lep1Pt"]) =  lep1Pt;
        *(floatBranches["lep2Pt"]) =  lep2Pt;
        *(floatBranches["lep1Eta"]) = lep1Eta;
        *(floatBranches["lep2Eta"]) = lep2Eta;
        *(floatBranches["maxLepEta"]) = lep1Eta*(fabs(lep1Eta)>=fabs(lep2Eta))+lep2Eta*(fabs(lep1Eta)<fabs(lep2Eta));
        *(floatBranches["maxLepAbsEta"]) = max(fabs(lep1Eta),fabs(lep2Eta));
        *(floatBranches["lep1Phi"]) = lep1Phi;
        *(floatBranches["lep2Phi"]) = lep2Phi;
        *(floatBranches["lep1Iso"]) = lep1Iso;
        *(floatBranches["lep2Iso"]) = lep2Iso;
        *(floatBranches["maxLepIso"]) = max(lep1Iso,lep2Iso);
        *(floatBranches["lep1TkCharge"]) = lep1TkCharge;
        *(floatBranches["lep2TkCharge"]) = lep2TkCharge;
        *(floatBranches["lep1GenCharge"]) = lep1GenCharge;
        *(floatBranches["lep2GenCharge"]) = lep2GenCharge;
        *(intBranches["lep1IsPrompt"]) = lep1IsPrompt;
        *(intBranches["lep2IsPrompt"]) = lep2IsPrompt;
        *(intBranches["lep1Flavor"]) = lep1Flavor;
        *(intBranches["lep2Flavor"]) = lep2Flavor;
        

        
        // jet variables
//         *(floatBranches["first_bjet_pt"]) = first_bjet_pt;
        *(floatBranches["first_jet_pt"]) = first_jet_pt;
        *(floatBranches["second_jet_pt"]) = second_jet_pt;
        *(floatBranches["third_jet_pt"]) = third_jet_pt;
        *(floatBranches["fourth_jet_pt"]) = fourth_jet_pt;
        
        *(floatBranches["first_jet_eta"]) = first_jet_eta;
        *(floatBranches["second_jet_eta"]) = second_jet_eta;
        *(floatBranches["third_jet_eta"]) = third_jet_eta;
        *(floatBranches["fourth_jet_eta"]) = fourth_jet_eta;

        *(floatBranches["b1_jet_pt"]) = b1_jet_pt;
        *(floatBranches["b2_jet_pt"]) = b2_jet_pt;
        *(floatBranches["b1_jet_eta"]) = b1_jet_eta;
        *(floatBranches["b2_jet_eta"]) = b2_jet_eta;
        *(floatBranches["b1_jet_CSV"]) = b1_jet_CSV;
        *(floatBranches["b2_jet_CSV"]) = b2_jet_CSV;
        
        //kinematic variables
        ////ANN neural net inputs
//         *(floatBranches["mass_of_everything"]) = mass_of_everything;
        *(floatBranches["min_dr_tagged_jets"]) = fmax(min_dr_tagged_jets,-1.0);
        *(floatBranches["mindr_lep1_jet"]) = mindr_lep1_jet;
        *(floatBranches["mindr_lep2_jet"]) = mindr_lep2_jet;
        *(floatBranches["avg_btag_disc_btags"]) = fmax(avg_btag_disc_btags,-1.0);
        *(floatBranches["Ht"]) = Ht;

        *(floatBranches["higgsLike_dijet_mass"]) = fmax(higgsLike_dijet_mass1,-1.0);
        *(floatBranches["higgsLike_dijet_mass2"]) = fmax(higgsLike_dijet_mass2,-1.0);
        *(intBranches["numHiggsLike_dijet_15"]) = numHiggsLike_dijet_15;
        *(floatBranches["numHiggsLike_dijet_15_float"]) = float(numHiggsLike_dijet_15);

        ////leptons
        *(floatBranches["mass_leplep"]) = mass_leplep;
        *(floatBranches["MT_leplep"]) = MT_leplep;
        *(floatBranches["pt_leplep"]) = pt_leplep;
        *(floatBranches["dPhi_leplep"]) = dPhi_leplep;
        *(floatBranches["dR_leplep"]) = dR_leplep;
        *(floatBranches["correctedDZ_leplep"]) = correctedDZ_leplep;
        *(floatBranches["correctedD0_leplep"]) = correctedD0_leplep;
        *(floatBranches["tkDZ_leplep"]) = tkDZ_leplep;
        ////everything
        *(floatBranches["all_sum_pt"]) = all_sum_pt;
        *(floatBranches["sum_pt"]) = sum_pt;
        *(floatBranches["sum_jet_pt"]) = sum_jet_pt;
//         *(floatBranches["pt_of_everything"]) = pt_of_everything;
//         *(floatBranches["pz_of_everything"]) = pz_of_everything;
//         *(floatBranches["pt_of_ttbar"]) = pt_of_ttbar;

      } //End if (CoreVariables)

      if (ExtraSameSignVariables) {
        if (debug_) cout << "Filling ExtraSameSignVariables" << endl;

//         *(floatBranches["lep1FlipSF"]) = lep1FlipSF;
//         *(floatBranches["lep2FlipSF"]) = lep2FlipSF;
        *(floatBranches["lepTotalFlipSF"]) = lepTotalFlipSF;
//         *(floatBranches["lep1FlipSFUp"]) = lep1FlipSFUp;
//         *(floatBranches["lep2FlipSFUp"]) = lep2FlipSFUp;
        *(floatBranches["lepTotalFlipSFUp"]) = lepTotalFlipSFUp;
//         *(floatBranches["lep1FlipSFDown"]) = lep1FlipSFDown;
//         *(floatBranches["lep2FlipSFDown"]) = lep2FlipSFDown;
        *(floatBranches["lepTotalFlipSFDown"]) = lepTotalFlipSFDown;
//         *(floatBranches["lep1PromptSF"]) = lep1PromptSF;
//         *(floatBranches["lep2PromptSF"]) = lep2PromptSF;
        *(floatBranches["lepTotalPromptSF"]) = lepTotalPromptSF;
//         *(floatBranches["lep1PromptSFUp"]) = lep1PromptSFUp;
//         *(floatBranches["lep2PromptSFUp"]) = lep2PromptSFUp;
        *(floatBranches["lepTotalPromptSFUp"]) = lepTotalPromptSFUp;
//         *(floatBranches["lep1PromptSFDown"]) = lep1PromptSFDown;
//         *(floatBranches["lep2PromptSFDown"]) = lep2PromptSFDown;
        *(floatBranches["lepTotalPromptSFDown"]) = lepTotalPromptSFDown;
//         *(intBranches["lep1PassSSCut"]) = lep1PassSSCut;
//         *(intBranches["lep2PassSSCut"]) = lep2PassSSCut;
        *(intBranches["lepTotalPassSSCut"]) = lepTotalPassSSCut;
        
        *(floatBranches["lep1GsfCharge"]) = lep1GsfCharge;
        *(floatBranches["lep2GsfCharge"]) = lep2GsfCharge;
        *(floatBranches["lep1ChargedIso"]) = lep1ChargedIso;
        *(floatBranches["lep2ChargedIso"]) = lep2ChargedIso;
        *(floatBranches["maxLepChargedIso"]) = max(lep1ChargedIso,lep2ChargedIso);
//         *(floatBranches["lep1NeutralIso"]) = lep1NeutralIso;
//         *(floatBranches["lep2NeutralIso"]) = lep2NeutralIso;
        *(floatBranches["lep1IP"]) = lep1IP;
        *(floatBranches["lep2IP"]) = lep2IP;
        *(floatBranches["lep1IPError"]) = lep1IPError;
        *(floatBranches["lep2IPError"]) = lep2IPError;
//         *(floatBranches["lep1dFracScEtTkPt"]) = lep1dFracScEtTkPt;
//         *(floatBranches["lep2dFracScEtTkPt"]) = lep2dFracScEtTkPt;

        *(floatBranches["mindr_lep1_allJet"]) = mindr_lep1_allJet;
        *(floatBranches["mindr_lep2_allJet"]) = mindr_lep2_allJet;
//         *(floatBranches["ptRel_lep1_jet"]) = ptRel_lep1_jet;
//         *(floatBranches["ptRel_lep2_jet"]) = ptRel_lep2_jet;
//         *(floatBranches["ptRel_lep1_allJet"]) = ptRel_lep1_allJet;
//         *(floatBranches["ptRel_lep2_allJet"]) = ptRel_lep2_allJet;

        *(floatBranches["wLike_dijet_mass_low1CSV"]) = fmax(wLike_dijet_mass_low1CSV1,-1.0);
        *(floatBranches["wLike_dijet_mass_low2CSV"]) = fmax(wLike_dijet_mass_low2CSV1,-1.0);
        *(floatBranches["wLike_dijet_pt_low1CSV"]) = fmax(wLike_dijet_pt_low1CSV,-1.0);
        *(floatBranches["wLike_dijet_pt_low2CSV"]) = fmax(wLike_dijet_pt_low2CSV,-1.0);
        *(floatBranches["wLike_dijet_eta_low1CSV"]) = fmax(wLike_dijet_eta_low1CSV,-5.0);
        *(floatBranches["wLike_dijet_eta_low2CSV"]) = fmax(wLike_dijet_eta_low2CSV,-5.0);
        *(floatBranches["topLike_trijet_mass_medTag_low1CSV"]) = fmax(topLike_trijet_mass_medTag_low1CSV1,-1.0);
        *(floatBranches["topLike_trijet_mass_looseTag_low1CSV"]) = fmax(topLike_trijet_mass_looseTag_low1CSV1,-1.0);
        *(floatBranches["topLike_trijet_mass_hiCSV_low1CSV"]) = fmax(topLike_trijet_mass_hiCSV_low1CSV1,-1.0);
        *(floatBranches["topLike_trijet_mass_medTag_low2CSV"]) = fmax(topLike_trijet_mass_medTag_low2CSV1,-1.0);
        *(floatBranches["topLike_trijet_mass_looseTag_low2CSV"]) = fmax(topLike_trijet_mass_looseTag_low2CSV1,-1.0);
        *(floatBranches["topLike_trijet_mass_hiCSV_low2CSV"]) = fmax(topLike_trijet_mass_hiCSV_low2CSV1,-1.0);
        *(floatBranches["topLike_dijet_lep1_mass_low1CSV"]) = fmax(topLike_dijet_lep1_mass_low1CSV,-1.0);
        *(floatBranches["topLike_dijet_lep1_mass_low2CSV"]) = fmax(topLike_dijet_lep1_mass_low2CSV,-1.0);
        *(floatBranches["topLike_dijet_lep2_mass_low1CSV"]) = fmax(topLike_dijet_lep2_mass_low1CSV,-1.0);
        *(floatBranches["topLike_dijet_lep2_mass_low2CSV"]) = fmax(topLike_dijet_lep2_mass_low2CSV,-1.0);
        *(floatBranches["MT_MHT_leplep"]) = MT_MHT_leplep;
        *(floatBranches["mass_MHT_leplep"]) = mass_MHT_leplep;
        *(floatBranches["MT_MHT_lep1"]) = MT_MHT_lep1;
        *(floatBranches["MT_MHT_lep2"]) = MT_MHT_lep2;
        *(floatBranches["MT_MHT_lep1_b1"]) = fmax(MT_MHT_lep1_b1,-1.0);
        *(floatBranches["MT_MHT_lep1_b2"]) = fmax(MT_MHT_lep1_b2,-1.0);
        *(floatBranches["MT_MHT_lep2_b1"]) = fmax(MT_MHT_lep2_b1,-1.0);
        *(floatBranches["MT_MHT_lep2_b2"]) = fmax(MT_MHT_lep2_b2,-1.0);
        *(floatBranches["MT_met_lep1_b1"]) = fmax(MT_met_lep1_b1,-1.0);
        *(floatBranches["MT_met_lep1_b2"]) = fmax(MT_met_lep1_b2,-1.0);
        *(floatBranches["MT_met_lep2_b1"]) = fmax(MT_met_lep2_b1,-1.0);
        *(floatBranches["MT_met_lep2_b2"]) = fmax(MT_met_lep2_b2,-1.0);
        *(floatBranches["MT_met_leplep"]) = MT_met_leplep;
        *(floatBranches["mass_met_leplep"]) = mass_met_leplep;
        *(floatBranches["MT_met_lep1"]) = MT_met_lep1;
        *(floatBranches["MT_met_lep2"]) = MT_met_lep2;
        *(floatBranches["mass_lep1_b1"]) = fmax(mass_lep1_b1,-1.0);
        *(floatBranches["mass_lep2_b1"]) = fmax(mass_lep2_b1,-1.0);
        *(floatBranches["mass_lep1_b2"]) = fmax(mass_lep1_b2,-1.0);
        *(floatBranches["mass_lep2_b2"]) = fmax(mass_lep2_b2,-1.0);
        *(floatBranches["dR_lep1_b1"]) = fmax(dR_lep1_b1,-1.0);
        *(floatBranches["dR_lep2_b1"]) = fmax(dR_lep2_b1,-1.0);
        *(floatBranches["dR_lep1_b2"]) = fmax(dR_lep1_b2,-1.0);
        *(floatBranches["dR_lep2_b2"]) = fmax(dR_lep2_b2,-1.0);
        

        *(intBranches["lep1GenMotherID"]) = lep1GenMotherID;
        *(intBranches["lep2GenMotherID"]) = lep2GenMotherID;
 
      }

        
        
      if (ExtraHiggsVariables) {
        if (debug_) cout << "Filling ExtraHiggsVariables" << endl;

        *(intBranches["numHiggsJets"]) = numHiggsJets;
        *(intBranches["numHiggsAllJets"]) = numHiggsAllJets;
        *(intBranches["HiggsDecayMode"]) = HtoCC*4 + HtoBB*5 + HtoTT*15 + HtoGG*21 + HtoZZ*23 + HtoWW*24;
        *(floatBranches["higgs_pt"]) = higgs_pt;
        *(floatBranches["higgs_pz"]) = higgs_pz;
        *(floatBranches["higgs_genJet_mass"]) = higgs_genJet_mass;
        *(floatBranches["higgs_genParton_mass"]) = higgs_genParton_mass;
        *(floatBranches["higgsLike_diBjet_mass"]) = fmax(higgsLike_diBjet_mass1,-1.0);
        *(floatBranches["higgsLike_allDijet_mass"]) = fmax(higgsLike_allDijet_mass1,-1.0);
        *(floatBranches["higgsLike_dijet_dR"]) = fmax(higgsLike_dijet_dR,-1.0);
        *(floatBranches["higgsLike_dijet_pt"]) = fmax(higgsLike_dijet_pt,-1.0);
        *(floatBranches["higgsLike_dijet_eta"]) = fmax(higgsLike_dijet_eta,-5.0);
        *(floatBranches["higgsLike_dijet_jet1_pt"]) = fmax(higgsLike_dijet_jet1_pt,-1.0);
        *(floatBranches["higgsLike_dijet_jet2_pt"]) = fmax(higgsLike_dijet_jet2_pt,-1.0);
        *(intBranches["numHiggsLike_dijet_10"]) = numHiggsLike_dijet_10;
        *(intBranches["numHiggsLike_dijet_20"]) = numHiggsLike_dijet_20;
        *(intBranches["numHiggsLike_dijet_25"]) = numHiggsLike_dijet_25;
        *(intBranches["numHiggsLike_diBjet_10"]) = numHiggsLike_diBjet_10;
        *(intBranches["numHiggsLike_diBjet_15"]) = numHiggsLike_diBjet_15;
        *(intBranches["numHiggsLike_diBjet_20"]) = numHiggsLike_diBjet_20;
        *(intBranches["numHiggsLike_diBjet_25"]) = numHiggsLike_diBjet_25;
        *(floatBranches["numHiggsLike_dijet_10_float"]) = float(numHiggsLike_dijet_10);
        *(floatBranches["numHiggsLike_dijet_20_float"]) = float(numHiggsLike_dijet_20);
        *(floatBranches["numHiggsLike_dijet_25_float"]) = float(numHiggsLike_dijet_25);
        *(floatBranches["numHiggsLike_diBjet_10_float"]) = float(numHiggsLike_diBjet_10);
        *(floatBranches["numHiggsLike_diBjet_15_float"]) = float(numHiggsLike_diBjet_15);
        *(floatBranches["numHiggsLike_diBjet_20_float"]) = float(numHiggsLike_diBjet_20);
        *(floatBranches["numHiggsLike_diBjet_25_float"]) = float(numHiggsLike_diBjet_25);
        
        *(floatBranches["higgs_dijet_mass"]) = higgs_dijet_mass;
        *(floatBranches["higgs_dijet_pt"]) = higgs_dijet_pt;
        *(floatBranches["higgs_dijet_pz"]) = higgs_dijet_pz;
        *(floatBranches["higgs_dijet_dR"]) = higgs_dijet_dR;
        *(floatBranches["higgs_dijet_dPhi"]) = higgs_dijet_dPhi;
        *(floatBranches["higgs_dijet_jet1_pt"]) = higgs_dijet_jet1_pt;
        *(floatBranches["higgs_dijet_jet2_pt"]) = higgs_dijet_jet2_pt;
        *(floatBranches["higgs_dijet_jet1_eta"]) = higgs_dijet_jet1_eta;
        *(floatBranches["higgs_dijet_jet2_eta"]) = higgs_dijet_jet2_eta;
        *(floatBranches["higgs_dijet_jet1_csv"]) = higgs_dijet_jet1_csv;
        *(floatBranches["higgs_dijet_jet2_csv"]) = higgs_dijet_jet2_csv;
//         *(floatBranches["higgs_dijet_jet1_Nconst"]) = higgs_dijet_jet1_Nconst;
//         *(floatBranches["higgs_dijet_jet2_Nconst"]) = higgs_dijet_jet2_Nconst;
//         *(floatBranches["higgs_dijet_jet1_btagSoftMuon"]) = higgs_dijet_jet1_btagSoftMuon;
//         *(floatBranches["higgs_dijet_jet2_btagSoftMuon"]) = higgs_dijet_jet2_btagSoftMuon;
//         *(floatBranches["higgs_dijet_jet1_btagSoftEle"]) = higgs_dijet_jet1_btagSoftEle;
//         *(floatBranches["higgs_dijet_jet2_btagSoftEle"]) = higgs_dijet_jet2_btagSoftEle;
//         *(floatBranches["higgs_dijet_jet1_leadCandPt"]) = higgs_dijet_jet1_leadCandPt;
//         *(floatBranches["higgs_dijet_jet2_leadCandPt"]) = higgs_dijet_jet2_leadCandPt;
//         *(floatBranches["higgs_dijet_jet1_leadCandDistFromPV"]) = higgs_dijet_jet1_leadCandDistFromPV;
//         *(floatBranches["higgs_dijet_jet2_leadCandDistFromPV"]) = higgs_dijet_jet2_leadCandDistFromPV;
//         *(floatBranches["higgs_dijet_genJet1_pt"]) = higgs_dijet_genJet1_pt;
//         *(floatBranches["higgs_dijet_genJet2_pt"]) = higgs_dijet_genJet2_pt;
//         *(floatBranches["higgs_dijet_genParton1_pt"]) = higgs_dijet_genParton1_pt;
//         *(floatBranches["higgs_dijet_genParton2_pt"]) = higgs_dijet_genParton2_pt;
//         *(floatBranches["higgs_dijet_jet1_muon_dR"]) = higgs_dijet_jet1_muon_dR;
//         *(floatBranches["higgs_dijet_jet2_muon_dR"]) = higgs_dijet_jet2_muon_dR;
//         *(floatBranches["higgs_dijet_jet1_electron_dR"]) = higgs_dijet_jet1_electron_dR;
//         *(floatBranches["higgs_dijet_jet2_electron_dR"]) = higgs_dijet_jet2_electron_dR;
//         *(floatBranches["higgs_dijet_jet1_track_dR"]) = higgs_dijet_jet1_track_dR;
//         *(floatBranches["higgs_dijet_jet2_track_dR"]) = higgs_dijet_jet2_track_dR;
//         *(floatBranches["higgs_dijet_jet1_track_pt"]) = higgs_dijet_jet1_track_pt;
//         *(floatBranches["higgs_dijet_jet2_track_pt"]) = higgs_dijet_jet2_track_pt;
        
      } //End if (ExtraHiggsVariables)
      if (ExtraJetVariables) {
      if (debug_) cout << "Filling ExtraJetVariables" << endl;

//         *(intBranches["numAllJets"]) = numAllJets;

//         *(floatBranches["first_jet_CHEF"]) = first_jet_CHEF;
//         *(floatBranches["second_jet_CHEF"]) = second_jet_CHEF;
//         *(floatBranches["third_jet_CHEF"]) = third_jet_CHEF;
//         *(floatBranches["fourth_jet_CHEF"]) = fourth_jet_CHEF;
//         *(floatBranches["sum_jet_CHEF"]) = sum_jet_CHEF;
        
//         *(floatBranches["first_jet_charge"]) = first_jet_charge;
//         *(floatBranches["second_jet_charge"]) = second_jet_charge;
//         *(floatBranches["third_jet_charge"]) = third_jet_charge;
//         *(floatBranches["fourth_jet_charge"]) = fourth_jet_charge;
//         *(floatBranches["sum_jet_charge"]) = sum_jet_charge;

//         *(floatBranches["sum_untagged_jet_charge"]) = sum_untagged_jet_charge;
//         *(floatBranches["sum_tagged_jet_charge"]) = sum_tagged_jet_charge;
//         *(floatBranches["leps_minus_jets_charge"]) = fabs(lep1TkCharge+lep2TkCharge-sum_jet_charge);
//         *(floatBranches["leps_minus_untagged_jets_charge"]) = fabs(lep1TkCharge+lep2TkCharge-sum_untagged_jet_charge);
//         *(floatBranches["leps_minus_tagged_jets_charge"]) = fabs(lep1TkCharge+lep2TkCharge-sum_tagged_jet_charge);

        *(floatBranches["first_jet_CSV"]) = first_jet_CSV;
        *(floatBranches["second_jet_CSV"]) = second_jet_CSV;
        *(floatBranches["third_jet_CSV"]) = third_jet_CSV;
        *(floatBranches["fourth_jet_CSV"]) = fourth_jet_CSV;

//         *(floatBranches["first_lf_jet_pt"]) = first_lf_jet_pt;
//         *(floatBranches["first_lf_jet_eta"]) = first_lf_jet_eta;
//         *(floatBranches["first_lf_jet_CSV_unshaped"]) = first_lf_jet_CSV_unshaped;
//         *(floatBranches["first_lf_jet_CSV_reshaped"]) = first_lf_jet_CSV_reshaped;

//         *(floatBranches["first_hf_jet_pt"]) = first_hf_jet_pt;
//         *(floatBranches["first_hf_jet_eta"]) = first_hf_jet_eta;
//         *(floatBranches["first_hf_jet_CSV_unshaped"]) = first_hf_jet_CSV_unshaped;
//         *(floatBranches["first_hf_jet_CSV_reshaped"]) = first_hf_jet_CSV_reshaped;

//         *(floatBranches["first_allJet_pt"]) = first_allJet_pt;
//         *(floatBranches["second_allJet_pt"]) = second_allJet_pt;
//         *(floatBranches["third_allJet_pt"]) = third_allJet_pt;
//         *(floatBranches["fourth_allJet_pt"]) = fourth_allJet_pt;

//         *(floatBranches["first_dibjet_mass"]) =  fmax(first_dibjet_mass,-1.0);
//         *(floatBranches["second_dibjet_mass"]) = fmax(second_dibjet_mass,-1.0);
//         *(floatBranches["third_dibjet_mass"]) =  fmax(third_dibjet_mass,-1.0);
//         *(floatBranches["lowest_dibjet_mass"]) =  fmax(lowest_dibjet_mass,-1.0);

//         *(floatBranches["first_untagged_dijet_mass"]) =  fmax(first_untagged_dijet_mass,-1.0);
//         *(floatBranches["second_untagged_dijet_mass"]) = fmax(second_untagged_dijet_mass,-1.0);
//         *(floatBranches["third_untagged_dijet_mass"]) =  fmax(third_untagged_dijet_mass,-1.0);
//         *(floatBranches["lowest_untagged_dijet_mass"]) =  fmax(lowest_untagged_dijet_mass,-1.0);

         *(floatBranches["dijet_mass_m2H"]) = fmax(dijet_mass_m2H,-1.0);
         *(floatBranches["dijet_mass_first"]) =  fmax(dijet_mass_first,-1.0);
//         *(floatBranches["dijet_mass_second"]) = fmax(dijet_mass_second,-1.0);
         *(floatBranches["dijet_mass_third"]) =  fmax(dijet_mass_third,-1.0);
//         *(floatBranches["dijet_mass_lowest"]) =  fmax(dijet_mass_lowest,-1.0);

//         *(floatBranches["min_dr_genB1_allJet"]) = min_dr_genB1_allJet;
//         *(floatBranches["min_dr_genB2_allJet"]) = min_dr_genB2_allJet;

//         *(floatBranches["CSV_30to45_0p0to1p2_1"]) = CSV_30to45_0p0to1p2_1;
//         *(floatBranches["CSV_45to75_0p0to1p2_1"]) = CSV_45to75_0p0to1p2_1;
//         *(floatBranches["CSV_75to150_0p0to1p2_1"]) = CSV_75to150_0p0to1p2_1;
//         *(floatBranches["CSV_150toInf_0p0to1p2_1"]) = CSV_150toInf_0p0to1p2_1;
//         *(floatBranches["CSV_30to45_1p2to2p1_1"]) = CSV_30to45_1p2to2p1_1;
//         *(floatBranches["CSV_45to75_1p2to2p1_1"]) = CSV_45to75_1p2to2p1_1;
//         *(floatBranches["CSV_75to150_1p2to2p1_1"]) = CSV_75to150_1p2to2p1_1;
//         *(floatBranches["CSV_150toInf_1p2to2p1_1"]) = CSV_150toInf_1p2to2p1_1;
//         *(floatBranches["CSV_30to45_2p1to2p4_1"]) = CSV_30to45_2p1to2p4_1;
//         *(floatBranches["CSV_45to75_2p1to2p4_1"]) = CSV_45to75_2p1to2p4_1;
//         *(floatBranches["CSV_75to150_2p1to2p4_1"]) = CSV_75to150_2p1to2p4_1;
//         *(floatBranches["CSV_150toInf_2p1to2p4_1"]) = CSV_150toInf_2p1to2p4_1;
        
//         *(floatBranches["CSV_30to45_0p0to1p2_2"]) = CSV_30to45_0p0to1p2_2;
//         *(floatBranches["CSV_45to75_0p0to1p2_2"]) = CSV_45to75_0p0to1p2_2;
//         *(floatBranches["CSV_75to150_0p0to1p2_2"]) = CSV_75to150_0p0to1p2_2;
//         *(floatBranches["CSV_150toInf_0p0to1p2_2"]) = CSV_150toInf_0p0to1p2_2;
//         *(floatBranches["CSV_30to45_1p2to2p1_2"]) = CSV_30to45_1p2to2p1_2;
//         *(floatBranches["CSV_45to75_1p2to2p1_2"]) = CSV_45to75_1p2to2p1_2;
//         *(floatBranches["CSV_75to150_1p2to2p1_2"]) = CSV_75to150_1p2to2p1_2;
//         *(floatBranches["CSV_150toInf_1p2to2p1_2"]) = CSV_150toInf_1p2to2p1_2;
//         *(floatBranches["CSV_30to45_2p1to2p4_2"]) = CSV_30to45_2p1to2p4_2;
//         *(floatBranches["CSV_45to75_2p1to2p4_2"]) = CSV_45to75_2p1to2p4_2;
//         *(floatBranches["CSV_75to150_2p1to2p4_2"]) = CSV_75to150_2p1to2p4_2;
//         *(floatBranches["CSV_150toInf_2p1to2p4_2"]) = CSV_150toInf_2p1to2p4_2;
        
      } //End if (ExtraJetVariables)
        
      if (ExtraTriggerVariables) {
      
        *(intBranches["isTriggerPassPrescaled"]) = isTriggerPassPrescaled ? 1 : 0;
        *(intBranches["isDoubleMuTriggerPS0"]) = isDoubleMuTriggerPS0 ? 1 : 0;
        *(intBranches["isDoubleElectronTriggerPS0"]) = isDoubleElectronTriggerPS0 ? 1 : 0;
        *(intBranches["isMuEGTriggerPS0"]) = isMuEGTriggerPS0 ? 1 : 0;
        *(intBranches["isMETTriggerPS0"]) = isMETTriggerPS0 ? 1 : 0;

        *(intBranches["isMu8Pass"]) =  HLT_Mu8_v ? 1 : 0;
        *(intBranches["isDoubleMu7Pass"]) =  HLT_DoubleMu7_v ? 1 : 0;
        *(intBranches["isMu13_Mu8Pass"]) =  HLT_Mu13_Mu8_v ? 1 : 0;
        *(intBranches["isMu17_Mu8Pass"]) =  HLT_Mu17_Mu8_v ? 1 : 0;
        *(intBranches["isMu17_TkMu8Pass"]) =  HLT_Mu17_TkMu8_v ? 1 : 0;
        *(intBranches["isMu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVLPass"]) =  HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v ? 1 : 0;
        *(intBranches["isMu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVLPass"]) =  HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v ? 1 : 0;
        *(intBranches["isEle17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVLPass"]) =  HLT_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v ? 1 : 0;
        *(intBranches["isEle8_CaloIdL_CaloIsoVLPass"]) =  HLT_Ele8_CaloIdL_CaloIsoVL_v ? 1 : 0;
        *(intBranches["isMu22_Photon22_CaloIdLPass"]) = HLT_Mu22_Photon22_CaloIdL_v ? 1 : 0;
        *(intBranches["isMu30_Ele30_CaloIdLPass"]) = HLT_Mu30_Ele30_CaloIdL_v ? 1 : 0;
        *(intBranches["isDiCentralPFJet30_PFMET80_BTagCSV07Pass"]) = HLT_DiCentralPFJet30_PFMET80_BTagCSV07_v ? 1 : 0;
        *(intBranches["isMET120_HBHENoiseCleanedPass"]) = HLT_MET120_HBHENoiseCleaned_v ? 1 : 0;
        *(intBranches["isMET200Pass"]) = HLT_MET200_v ? 1 : 0;
        *(intBranches["isPFMET150Pass"]) = HLT_PFMET150_v ? 1 : 0;

      } //End if (ExtraTriggerVariables)

      if (ExtraGenVariables) {
      if (debug_) cout << "Filling ExtraGenVariables" << endl;

//         *(intBranches["lep1GenID"]) = lep1GenID;
//         *(intBranches["lep2GenID"]) = lep2GenID;
        *(intBranches["first_jet_genID"]) = first_jet_genID;
        *(intBranches["second_jet_genID"]) = second_jet_genID;
        *(intBranches["third_jet_genID"]) = third_jet_genID;
        *(intBranches["fourth_jet_genID"]) = fourth_jet_genID;
        *(intBranches["first_jet_flavor"]) = first_jet_flavor;
        *(intBranches["second_jet_flavor"]) = second_jet_flavor;
        *(intBranches["third_jet_flavor"]) = third_jet_flavor;
        *(intBranches["fourth_jet_flavor"]) = fourth_jet_flavor;
//         *(floatBranches["top1_pt"]) = top1_pt;
//         *(floatBranches["top1_pz"]) = top1_pz;

      } //End if (ExtraGenVariables)
      

      if (ExtraKinematicVariables) {
        if (debug_) cout << "Filling ExtraKinematicVariables" << endl;
        
        ////objects
// 	    *(floatBranches["m2H_btag"]) = m2H_btag;        
//         *(floatBranches["wLike_allDijet_mass"]) = fmax(wLike_allDijet_mass1,-1.0);
//         *(floatBranches["topLike_allTrijet_mass"]) = fmax(topLike_allTrijet_mass1,-1.0);

//         ////leptons
//         *(floatBranches["dEta_leplep"]) = dEta_leplep;
//         *(floatBranches["MT_met_lep1"]) = MT_met_lep1;
//         *(floatBranches["MT_met_lep2"]) = MT_met_lep2;
//         *(floatBranches["dPhi_met_lep1"]) = dPhi_met_lep1;
//         *(floatBranches["dPhi_met_lep2"]) = dPhi_met_lep2;
        ////everything
//         *(intBranches["PassZmask3"]) = PassBigDiamondZmask3 ? 1 : 0;

        *(floatBranches["min_dr_jets"]) = min_dr_jets;
	*(floatBranches["avg_dr_jets"]) = avg_dr_jets;
	*(floatBranches["avg_dr_tagged_jets"]) = avg_dr_tagged_jets;

	*(floatBranches["avg_tagged_dijet_mass"]) = avg_tagged_dijet_mass;
//         *(floatBranches["avg_untagged_dijet_mass"]) = avg_untagged_dijet_mass;
	*(floatBranches["avg_dijet_mass"]) = avg_dijet_mass;
// 	    *(floatBranches["M2_of_closest_jets"]) = M2_of_closest_jets;
// 	    *(floatBranches["M2_of_closest_tagged_jets"]) = M2_of_closest_tagged_jets;
// 	    *(floatBranches["closest_dijet_mass"]) = closest_dijet_mass;
//         *(floatBranches["closest_tagged_dijet_mass"]) = closest_tagged_dijet_mass;

        *(floatBranches["avg_btag_disc_non_btags"]) = avg_btag_disc_non_btags;
//         *(floatBranches["highest_btag_disc_non_btags"]) = highest_btag_disc_non_btags;
//         *(floatBranches["dev_from_avg_disc_btags"]) = dev_from_avg_disc_btags;
// 	    *(floatBranches["first_highest_btag"]) = first_highest_btag;
// 	    *(floatBranches["second_highest_btag"]) = second_highest_btag;
// 	    *(floatBranches["lowest_btag"]) = lowest_btag;

//         *(floatBranches["mass_MHT"]) = mass_MHT;
//         *(floatBranches["mass_of_leps_and_allJets"]) = mass_of_leps_and_allJets;
//         *(floatBranches["pt_of_leps_and_allJets"]) = pt_of_leps_and_allJets;
//         *(floatBranches["pt_of_allEverything"]) = pt_of_allEverything;

      } //End if (ExtraKinematicVariables)

      if (ExtraLeptonVariables) {

        *(intBranches["lep2IsGlobalMuon"]) = lep2IsGlobalMuon;
        *(intBranches["lep2IsTrackerMuon"]) = lep2IsTrackerMuon;
        *(intBranches["lep2IsGlobalMuonPromptTight"]) = lep2IsGlobalMuonPromptTight;
        *(intBranches["lep2NumTrackHits"]) = lep2NumTrackHits;
        *(intBranches["lep2NumPixelHits"]) = lep2NumPixelHits;
        *(intBranches["lep2NumberOfMatches"]) = lep2NumberOfMatches;
        *(floatBranches["lep2Chi2"]) = lep2Chi2;
        *(intBranches["lep2NumExpectedHits"]) = lep2NumExpectedHits;

      } //End if (ExtraLeptonVariables)
        
      if (debug_) std::cout << "OUTPUT VARIABLES: " <<
        "runNumber : " << event->run << " , " <<  
        "eventNumber : " << event->lumi << " , " << 
        "luminosityBlock : " << event->evt << " , " << 
        "numTightMuons : " << numTightMuons << " , " << 
        "numTightElectrons : " << numTightElectrons << " , " << 
        "numLooseMuons : " << numLooseMuons << " , " << 
        "numLooseElectrons : " << numLooseElectrons << " , " << 
        "numJets : " << numJets << " , " << 
        "numTaggedJets : " << numTaggedJets << " , " << 
        "numPV : " << numPV << " , " << 
        "lep1Pt : " << setprecision(3) << lep1Pt << " , " << 
        "lep1Eta : " << setprecision(3) << lep1Eta << " , " << 
        "lep1Iso : " << setprecision(3) << lep1Iso << " , " << 
        "lep2Pt : " << setprecision(3) << lep2Pt << " , " << 
        "lep2Eta : " << setprecision(3) << lep2Eta << " , " << 
        "lep2Iso : " << setprecision(3) << lep2Iso << " , " << 
        "met : " << setprecision(3) << met << " , " << 
        "Ht : " << setprecision(3) << Ht << " , " << 
        "first_jet_pt : " << setprecision(3) << first_jet_pt << " , " << 
        "first_jet_eta : " << setprecision(3) << first_jet_eta << " , " << 
        "second_jet_pt : " << setprecision(3) << second_jet_pt << " , " << 
        "second_jet_eta : " << setprecision(3) << second_jet_eta << " , " << 
        "avg_btag_disc_btags : " << setprecision(3) << avg_btag_disc_btags << " , " <<
        "highest_btag_disc_non_btags : " << setprecision(3) << highest_btag_disc_non_btags << " , " <<
        "first_jet_CSV : " << setprecision(3) << first_jet_CSV << " , " << 
        "second_jet_CSV : " << setprecision(3) << second_jet_CSV << " , " << 
        "weight : " << setprecision(3) << weight << " , " << 
        "weight_PUup : " << setprecision(3) << weight_PUup << " , " << 
        "weight_PUdown : " << setprecision(3) << weight_PUdown << " , " << 
//         "HtWgt : " << setprecision(3) << HtWgt << " , " << 
//         "HtWgtUp : " << setprecision(3) << HtWgtUp << " , " << 
        "Q2ScaleUpWgt : " << setprecision(3) << Q2ScaleUpWgt << " , " << 
        "Q2ScaleDownWgt : " << setprecision(3) << Q2ScaleDownWgt << " , " << 
        std::endl;

      

      } // end neural net selection


      if (verbose) std::cout << "about to fill tree" <<std::endl;
      
      summaryTree->Fill();
      

    } // end loop over events


  }// end try
  catch(std::exception& e) {
    std::cerr << " ==> caught exception " << e.what() << std::endl;

    std::cerr << " Whatever it was, it probably wasn't good, so I will crash" << std::endl;
    bool foundException = true;
    assert (foundException == false);
    //continue;
  }


  std::cout << "\n\nDone with loop over events\n\n" << std::endl;
  
  histofile.Write();
  histofile.Close();

  std::cout << " Done! " << std::endl;

}
